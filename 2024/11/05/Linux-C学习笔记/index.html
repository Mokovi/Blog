<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux C学习笔记 | MegaV的博客</title><meta name="author" content="MegaV"><meta name="copyright" content="MegaV"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux C学习笔记">
<meta property="og:url" content="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MegaV的博客">
<meta property="og:description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/user.jpg">
<meta property="article:published_time" content="2024-11-05T11:33:22.000Z">
<meta property="article:modified_time" content="2024-11-06T15:46:17.027Z">
<meta property="article:author" content="MegaV">
<meta property="article:tag" content="Linux, C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/user.jpg"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux C学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-06 23:46:17',
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MegaV的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux C学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Linux C学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-06T15:46:17.027Z" title="Updated 2024-11-06 23:46:17">2024-11-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零碎知识小结"><a href="#零碎知识小结" class="headerlink" title="零碎知识小结"></a>零碎知识小结</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。</p>
<h3 id="GCC的编译过程"><a href="#GCC的编译过程" class="headerlink" title="GCC的编译过程"></a>GCC的编译过程</h3><p>程序的编译过程可以分为四个主要阶段：</p>
<ol>
<li><p><strong>预编译</strong>：该阶段进行宏替换、删除注释、头文件包含以及条件编译等操作，生成一个预处理文件（<code>.i</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编译</strong>：将预处理后的<code>.i</code>文件编译成汇编文件（<code>.s</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>汇编</strong>：将汇编文件转换为二进制目标文件（<code>.o</code>），即机器代码。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>链接</strong>：将目标文件与库函数和启动代码链接，生成最终的可执行文件（通常是<code>a.out</code>，或在Windows下为<code>a.exe</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的使用方式"><a href="#GCC的使用方式" class="headerlink" title="GCC的使用方式"></a>GCC的使用方式</h3><ol>
<li><p><strong>一步到位的编译</strong>：<br>默认情况下，GCC会将源代码直接编译成一个可执行文件<code>a.out</code>。</p>
<ul>
<li>编译并生成可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure></li>
<li>运行程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure></li>
<li>指定输出文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o myhello</span><br><span class="line">./myhello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分步编译</strong>：<br>编译过程可以分为多个步骤进行，每个步骤都可以单独执行：</p>
<ul>
<li>预处理：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
<li>编译：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
<li>汇编：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
<li>链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>警告信息</strong>：<br>使用<code>-Wall</code>选项可以查看编译时的警告信息，有助于排除潜在的代码问题。</p>
<ul>
<li>编译并显示警告：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -Wall</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的主要特点"><a href="#GCC的主要特点" class="headerlink" title="GCC的主要特点"></a>GCC的主要特点</h3><ul>
<li><strong>多语言支持</strong>：GCC支持C、C++、Fortran、Ada、Go、Objective-C、D等多种编程语言。</li>
<li><strong>优化能力</strong>：GCC提供多种优化选项，如<code>-O2</code>、<code>-O3</code>等，帮助提升代码执行效率。</li>
<li><strong>跨平台支持</strong>：GCC支持多个操作系统和平台，如Linux、Windows、macOS、ARM等。</li>
<li><strong>标准化支持</strong>：GCC支持各种语言标准，特别是C和C++的最新标准。</li>
<li><strong>调试支持</strong>：GCC与调试器（如GDB）集成，提供调试功能。</li>
</ul>
<p>总结来说，GCC是一个强大的、开源的编译工具，适用于多种编程语言，并提供了丰富的优化和调试功能，广泛应用于各种开发场景。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>​	POSIX（<strong>Portable Operating System Interface for Unix</strong>）标准是由IEEE（Institute of Electrical and Electronics Engineers）制定的一系列标准，旨在定义操作系统接口（如系统调用、库函数等），以确保不同Unix系统之间的兼容性和可移植性。POSIX标准主要关注Unix和类Unix操作系统（如Linux、macOS、AIX等）之间的兼容性和一致性，使得应用程序能够在不同的操作系统平台之间移植而不需要进行大量的修改。</p>
<hr>
<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p><strong>1.程序和进程的区别：</strong> </p>
<p>​	<strong>程序：是静态的，存放在磁盘上的可执行文件</strong> </p>
<p>​	<strong>进程：是动态的，是运行在内存中的程序的执行实例</strong></p>
<p>​	程序是一些指令的有序集合，而进程是程序执行的过程，进程是程序的一次执行过程。 进程的状态是变化的，其包括进程的创建、调度和消亡。 当程序运行时，其就是进程，程序每运行一次，就会创建一个进程。在linux系统中，进程是管理事务的基本单元。 进程拥有自己独立的处理环境和系统资源（处理器、存储器、I&#x2F;O设备、数据、程序）。</p>
<p><strong>2.进程的状态及转换</strong></p>
<p>进程整个生命周期可以简单划分为<strong>三种状态</strong>： </p>
<p>​	<strong>就绪态：</strong> 进程已经具备执行的一切条件，正在等待分配CPU的处理时间。 </p>
<p>​	<strong>执行态：</strong> 该进程正在占用CPU运行。 </p>
<p>​	<strong>等待态：</strong> 进程因不具备某些执行条件而暂时无法继续执行的状态。</p>
<p><strong>进程三个状态的转换关系</strong></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/1.png"></p>
<p>引起进程状态转换的具体原因如下：</p>
<p>​	<strong>运行态→等待态</strong>：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>​	<strong>等待态→就绪态</strong>：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>​	<strong>运行态→就绪态</strong>：运行时间片到；出现有更高优先权进程。</p>
<p>​	<strong>就绪态—→运行态</strong>：CPU 空闲时选择一个就绪进程</p>
<h2 id="进程的调度进制："><a href="#进程的调度进制：" class="headerlink" title="进程的调度进制："></a><strong>进程的调度进制：</strong></h2><p>​	多进程不是说一个进程执行完再执行另一个进程，而是交替执行的，一个进程执行一段时间，然后下一个进程在执行一段时间，依次类推，所有进程执行完之后再回到第一个进程继续执行由此类推。在操作系统中，时间片轮转调度（Round Robin Scheduling）、优先级调度（Priority Scheduling）和完全公平调度（Completely Fair Scheduling，CFS）是三种常见的进程调度算法。</p>
<h3 id="时间片轮转调度（Round-Robin-Scheduling）"><a href="#时间片轮转调度（Round-Robin-Scheduling）" class="headerlink" title="时间片轮转调度（Round Robin Scheduling）"></a><strong>时间片轮转调度（Round Robin Scheduling）</strong></h3><p><strong>概述</strong>：<br>    时间片轮转调度是一种简单且常用的调度策略，特别适用于多任务环境中的时间共享系统。该策略的核心思想是为每个进程分配一个固定的时间片（Time Slice），当一个进程用完它的时间片后，操作系统会将其挂起，将CPU资源分配给下一个进程。所有的进程按顺序轮流执行，保证每个进程都能获得一定的CPU时间。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程按照固定的时间片执行，当时间片耗尽时，调度器会将进程切换出去，并将其状态保存，再选择下一个进程执行。</li>
<li>如果进程在其时间片内完成了任务，则该进程会被移除调度队列，继续执行下一个任务。</li>
<li>如果进程没有在时间片内完成，调度器会将其放回队列末尾，等待下次调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易实现，适用于多任务操作系统。</li>
<li>每个进程都可以得到公平的CPU时间。</li>
<li>特别适用于交互式任务，避免某些进程独占CPU时间。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果时间片设置得太小，频繁的上下文切换会增加开销。</li>
<li>不考虑进程的优先级，可能导致重要的进程在轮转时被延迟。</li>
<li>时间片的选择要合适，过大或过小都会影响系统性能。</li>
</ul>
<p><strong>应用场景</strong>：<br>适用于一般的桌面操作系统和基于时间共享的系统，如Linux和Windows中的用户进程调度。</p>
<h3 id="优先级调度（Priority-Scheduling）"><a href="#优先级调度（Priority-Scheduling）" class="headerlink" title="优先级调度（Priority Scheduling）"></a><strong>优先级调度（Priority Scheduling）</strong></h3><p><strong>概述</strong>：<br>优先级调度是一种基于优先级的调度算法。每个进程都被分配一个优先级值，调度器总是选择优先级最高的进程来执行。高优先级进程会优先于低优先级进程执行，直到它完成或者被阻塞为止。优先级可以是静态的（在进程创建时确定），也可以是动态的（在运行过程中根据进程的行为或外部因素调整）。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程有一个优先级，优先级可以由系统静态设定，或由用户和操作系统动态调整。</li>
<li>调度器选择队列中优先级最高的进程执行，如果多个进程优先级相同，则采用其他算法（如时间片轮转）来调度。</li>
<li>优先级调度可以是抢占式的，即当一个高优先级进程到达时，会抢占正在运行的低优先级进程；也可以是非抢占式的，即进程执行完一个时间片后才会进行调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可以确保高优先级的进程能及时得到执行，适合有不同重要性的任务。</li>
<li>对于实时任务或需要快速响应的进程非常有用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>饥饿问题（Starvation）</strong>：低优先级的进程可能长时间得不到执行，特别是在高优先级进程一直占用CPU时。</li>
<li>不适用于所有任务，因为它忽视了进程的执行时间和公平性。</li>
<li>动态优先级调整可能增加系统的复杂性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于实时操作系统或任务需要严格响应时间的系统。</li>
<li>比如嵌入式系统中的任务调度和硬实时系统。</li>
</ul>
<h3 id="完全公平调度（CFS，Completely-Fair-Scheduling）"><a href="#完全公平调度（CFS，Completely-Fair-Scheduling）" class="headerlink" title="完全公平调度（CFS，Completely Fair Scheduling）"></a><strong>完全公平调度（CFS，Completely Fair Scheduling）</strong></h3><p><strong>概述</strong>：<br>完全公平调度（CFS）是Linux操作系统默认的调度算法，旨在为每个进程提供一个“公平”的CPU时间。与时间片轮转调度不同，CFS不使用固定的时间片，而是使用进程的“虚拟运行时间”（<code>virtual runtime</code>，简称<code>vruntime</code>）来决定哪个进程应该运行。CFS的目标是让每个进程尽可能公平地获得CPU时间，而不是通过固定的时间片来分配资源。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程都有一个<code>vruntime</code>值，表示该进程消耗的CPU时间。当一个进程运行时，它的<code>vruntime</code>会增加。</li>
<li>CFS通过一个红黑树（Red-Black Tree）来管理可执行的进程，树的根节点是<code>vruntime</code>最小的进程，这意味着它会被优先执行。</li>
<li>进程的<code>vruntime</code>会根据其实际运行时间动态调整，长时间运行的进程会让出CPU，短时间运行的进程会被优先调度。</li>
<li>CFS没有固定的时间片，而是基于进程的<code>vruntime</code>来决定调度顺序，进程越公平，<code>vruntime</code>的增加就越慢，调度时得到的CPU时间就越多。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>公平性</strong>：CFS最大程度地保证了进程之间的公平性，每个进程根据其CPU消耗时间来动态调整调度顺序。</li>
<li><strong>灵活性</strong>：相比时间片轮转调度，CFS具有更高的灵活性，可以动态调整每个进程的CPU时间分配，避免了不必要的频繁上下文切换。</li>
<li><strong>低延迟</strong>：对交互式进程提供较低的调度延迟，因为它总是优先调度<code>vruntime</code>较小的进程。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性较高，调度机制依赖于红黑树的实现，可能会增加系统的开销。</li>
<li>对于一些实时应用来说，CFS可能不能提供足够的响应保证，因为它更注重公平性而非严格的实时性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于需要平衡性能和公平性的多任务操作系统，如Linux。CFS是Linux的默认调度算法，适合各种通用计算任务。</li>
<li>不适用于实时性要求较高的任务。</li>
</ul>
<h4 id="CFS实例"><a href="#CFS实例" class="headerlink" title="CFS实例"></a>CFS实例</h4><p>​	为了更好地说明 <strong>完全公平调度（CFS）</strong> 的工作原理，我们可以通过一个更完善的例子来展示进程如何基于 <code>vruntime</code> 值进行调度，并解释不同优先级的进程如何影响 <code>vruntime</code> 的增长速率。</p>
<p>假设场景：</p>
<ul>
<li>系统中有三个进程：<code>进程 A</code>、<code>进程 B</code> 和 <code>进程 C</code>。</li>
<li>进程 A 是高优先级进程，<code>权重 = 1024</code>。</li>
<li>进程 B 是中等优先级进程，<code>权重 = 512</code>。</li>
<li>进程 C 是低优先级进程，<code>权重 = 256</code>。</li>
</ul>
<p>所有进程的初始 <code>vruntime</code> 为 0。</p>
<p>在此例中，我们假设每个进程的 <strong>执行时间</strong> 都为 5 毫秒。</p>
<p>步骤 1：进程 A 执行</p>
<ul>
<li><p>初始时，<code>进程 A</code> 的 <code>vruntime = 0</code>，<code>进程 B</code> 和 <code>进程 C</code> 的 <code>vruntime = 0</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 A</code> 执行，因为它的 <code>vruntime</code> 最小。</p>
</li>
<li><p>进程 A 执行了 5 毫秒。由于 <code>进程 A</code> 的权重为 1024，它的 <code>vruntime</code> 增加的速率较慢。假设 <code>vruntime</code> 增加的计算公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime 增加量 = 执行时间 × 权重因子 / 权重</span><br></pre></td></tr></table></figure>

<p>假设权重因子为 1，进程 A 的 <code>vruntime</code> 增加量是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_A = 5 × 1 / 1024 ≈ 0.00488</span><br></pre></td></tr></table></figure>

<p>进程 A 执行完后，<code>vruntime_A</code> 的新值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_A = 0 + 0.00488 = 0.00488</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 A</code> 执行完后的 <code>vruntime = 0.00488</code>。</p>
</li>
</ul>
<p>步骤 2：进程 C 执行</p>
<ul>
<li><p>当前时刻，<code>进程 A</code> 的 <code>vruntime = 0.00488</code>，<code>进程 B</code> 的 <code>vruntime = 0</code>，<code>进程 C</code> 的 <code>vruntime = 0</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 C</code> 执行，因为它的 <code>vruntime</code> 最小（与进程 B 相同，选择顺序可能不同，但我们假设先执行 C）。</p>
</li>
<li><p>进程 C 执行了 5 毫秒。由于 <code>进程 C</code> 的权重为 256，它的 <code>vruntime</code> 增加量会比进程 A 大。计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_C = 5 × 1 / 256 ≈ 0.01953</span><br></pre></td></tr></table></figure>

<p>进程 C 执行完后的 <code>vruntime</code> 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_C = 0 + 0.01953 = 0.01953</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 C</code> 执行完后的 <code>vruntime = 0.01953</code>。</p>
</li>
</ul>
<p>步骤 3：进程 B 执行</p>
<ul>
<li><p>当前时刻，<code>进程 A</code> 的 <code>vruntime = 0.00488</code>，<code>进程 B</code> 的 <code>vruntime = 0</code>，<code>进程 C</code> 的 <code>vruntime = 0.01953</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 B</code> 执行，因为它的 <code>vruntime</code> 最小。</p>
</li>
<li><p>进程 B 执行了 5 毫秒。由于 <code>进程 B</code> 的权重为 512，它的 <code>vruntime</code> 增加量比进程 A 小，但比进程 C 大。计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_B = 5 × 1 / 512 ≈ 0.00977</span><br></pre></td></tr></table></figure>

<p>进程 B 执行完后的 <code>vruntime</code> 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_B = 0 + 0.00977 = 0.00977</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 B</code> 执行完后的 <code>vruntime = 0.00977</code>。</p>
</li>
</ul>
<p>步骤 4：再次调度</p>
<p>此时，进程 A、B 和 C 的 <code>vruntime</code> 分别为：</p>
<ul>
<li><code>进程 A</code>：<code>vruntime = 0.00488</code></li>
<li><code>进程 B</code>：<code>vruntime = 0.00977</code></li>
<li><code>进程 C</code>：<code>vruntime = 0.01953</code></li>
</ul>
<p>接下来，CFS 会选择 <strong><code>vruntime</code> 最小的进程</strong> 来执行，这个进程是 <code>进程 A</code>，它的 <code>vruntime</code> 最小。然后调度会继续按照这种方式进行，直到所有进程完成执行。</p>
<p><strong>总结</strong>：</p>
<ol>
<li><p><strong>权重（优先级）决定了 <code>vruntime</code> 的增长速率</strong>：</p>
<ul>
<li>高优先级的进程（权重大）其 <code>vruntime</code> 增长较慢，因此可以更长时间占用 CPU。</li>
<li>低优先级的进程（权小）其 <code>vruntime</code> 增长较快，因此调度时优先级较低。</li>
</ul>
</li>
<li><p><strong>进程调度顺序是基于 <code>vruntime</code> 的</strong>，<code>vruntime</code> 越小的进程越容易被调度执行，CFS 会按照进程的 <code>vruntime</code> 值维护一个红黑树（基于红黑树来管理所有可执行的进程）。</p>
</li>
<li><p><strong>公平性</strong>：CFS 会确保所有进程在理论上能够获得相同的 CPU 时间，通过动态调整 <code>vruntime</code>，使得长期运行的进程逐渐让出 CPU 给其他进程。</p>
</li>
</ol>
<p>这种调度方式与传统的基于时间片的调度算法（如时间片轮转）不同，它根据每个进程的实际执行情况来调整调度策略，确保了调度的公平性。</p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a><strong>进程控制块</strong></h2><p>​	<strong>进程控制块</strong>就是用于保存一个进程信息的结构体，又称之为<strong>PCB</strong>。OS是根据PCB来对并发执行的进程进行控制和管理的。系统在创建一个进程的时候会开辟 一段内存空间存放与此进程相关的PCB数据结构。 PCB是操作系统中最重要的记录型数据结构。PCB中记录了用于描述进程进展情况及控制进程运行所需的全部信息。 </p>
<p>​	PCB是进程存在的唯一标志，在Linux中PCB存放在task_struct结构体中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/src</span><br><span class="line">$ <span class="built_in">sudo</span> apt-get install ctags</span><br><span class="line"><span class="built_in">sudo</span> ctags -R</span><br><span class="line"></span><br><span class="line">查看结构体  vim -t task_struct</span><br></pre></td></tr></table></figure>

<p>​	调度数据 (进程的状态,标记优先级,调度策略等)</p>
<p>​	时间数据: 创建该进程的时间,在用户态的运行时间,在内核态的运行时间.</p>
<p>​	文件数据： 文件描述符表,内存数据,进程标识(进程号)</p>
<hr>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h1><h2 id="进程号"><a href="#进程号" class="headerlink" title="进程号"></a><strong>进程号</strong></h2><p>​	每个进程都由一个进程号来标识，其类型为pid_t，进程号的范围：0～32767。进程号是由操作系统随机给当前进程分配的，不能自己控制。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用了</p>
<p>在ubuntu中查看当前系统中所有的开启的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ajx</span><br></pre></td></tr></table></figure>

<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/2.png"></p>
<p><strong>特殊的进程号：</strong> </p>
<p>在linux系统中进程号由0开始。进程号为0及1的进程由内核创建；</p>
<ul>
<li><p>进程号为0的进程通常是调度进程，常被称为交换进程(swapper)；</p>
</li>
<li><p>进程号为1的进程通常是init进程，init进程是所有进程的祖先。除调度进程外，在linux下面所有的进程都由进程init进程直接或者间接创建。</p>
</li>
</ul>
<p><strong>进程号(PID)</strong> ：标识进程的一个非负整型数。 </p>
<p><strong>父进程号(PPID)</strong> ：任何进程(除init进程)都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号(PPID)。 </p>
<p><strong>进程组号(PGID)</strong> ：进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种 </p>
<p>信号，关联的进程有一个进程组号(PGID) 。 </p>
<p><strong>COMMAND</strong>：当前进程的名字 </p>
<p><strong>Linux操作系统提供了三个获得进程号的函数getpid()、getppid()、getpgid()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man getpid    man getpgid</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t getpid(void);</span><br><span class="line">功能：获取当前进程的进程号</span><br><span class="line">pid_t getppid(void);</span><br><span class="line">功能：获取当前进程的父进程的进程号</span><br><span class="line">pid_t getpgid(pid_t pid);</span><br><span class="line">功能：获取当前进程所在进程组的id</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//获取当前进程的进程号</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, getpid());</span><br><span class="line"> <span class="comment">//获取当前进程的父进程的id</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ppid = %d\n&quot;</span>, getppid());</span><br><span class="line"> <span class="comment">//获取当前进程所在组的id</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pgid = %d\n&quot;</span>, getpgid(getpid()));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/3.png"></p>
<h2 id="进程的创建fork函数"><a href="#进程的创建fork函数" class="headerlink" title="进程的创建fork函数"></a>进程的创建fork函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能: 在已有的进程基础上创建一个子进程.</span><br><span class="line">参数无</span><br><span class="line">返回值:</span><br><span class="line">  成功:</span><br><span class="line">   	&gt;<span class="number">0</span> 子进程的进程号,标识父进程的代码区</span><br><span class="line">  	 <span class="number">0</span>  子进程的代码区</span><br><span class="line">  失败:</span><br><span class="line">    <span class="number">-1</span>  返回给父进程,子进程不会创建.</span><br></pre></td></tr></table></figure>

<p>使用fork函数得到的子进程是父进程的一个复制品,它从父进程处继承了整个进程的地址空间。</p>
<p>地址空间：包括进程上下文,进程堆栈,打开的文件描述,信号控制设定,进程优先级,进程组号等。子进程所独有的只有它的进程号,计时器,因此,使用fork函数的代价是很大的.</p>
<p>  <strong>fork函数执行完毕后父子进程的空间示意图：</strong></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/4.png"></p>
<h2 id="程序区域划分"><a href="#程序区域划分" class="headerlink" title="程序区域划分"></a>程序区域划分</h2><p>在程序运行时，内存被分为不同的区域，用来存储代码、数据、堆栈等内容。</p>
<ol>
<li><strong>栈区</strong>（Stack Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 栈区用于存储函数调用过程中自动分配的局部变量、函数参数和返回地址等数据。栈区的内存由系统自动分配和释放，遵循后进先出的原则。</li>
<li><strong>特点</strong>:<ul>
<li><strong>自动管理</strong>: 当函数被调用时，局部变量在栈上分配；函数返回时，栈上的局部变量会自动销毁。</li>
<li><strong>空间有限</strong>: 栈的大小通常是有限的，过大的递归调用或分配过多的局部变量可能导致栈溢出（Stack Overflow）。</li>
<li><strong>高速存取</strong>: 栈内存的分配和释放速度非常快。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>堆区</strong>（Heap Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 堆区用于动态分配内存，通常由程序员手动分配和释放（例如通过 <code>new</code> 和 <code>delete</code> 等函数在 C&#x2F;C++ 中进行操作）。堆的内存可以在程序运行时动态增长或缩减。</li>
<li><strong>特点</strong>:<ul>
<li><strong>手动管理</strong>: 程序员负责内存的分配和释放，使用不当可能导致内存泄漏或碎片化。</li>
<li><strong>较大空间</strong>: 与栈相比，堆的内存空间通常更大，可以用于分配大块的内存。</li>
<li><strong>灵活性高</strong>: 适合不确定大小的数据结构，例如链表、树等。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>BSS</strong>区（BSS Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: BSS 区（Block Started by Symbol）用于存放未初始化的全局变量和静态变量。该区域在程序加载时由操作系统初始化为零。</li>
<li><strong>特点</strong>:<ul>
<li><strong>零初始化</strong>: 所有在 BSS 区的变量在程序运行前都会被自动清零。</li>
<li><strong>只存储未初始化数据</strong>: 如果全局或静态变量在定义时没有显式初始化，它们就会被放在 BSS 区。</li>
<li><strong>节省空间</strong>: 未初始化的变量并不占用可执行文件中的空间，它们只是在程序运行时才占用内存。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>数据区</strong>（Data Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 数据区用于存放已初始化的全局变量和静态变量。这些变量的初始值会随程序一起加载进内存，并在整个程序的生命周期内存在。</li>
<li><strong>特点</strong>:<ul>
<li><strong>全局存储</strong>: 包含了所有程序中已初始化的全局变量和静态变量。</li>
<li><strong>可读写</strong>: 数据区中的变量在程序运行期间是可读写的，不会随函数的调用和结束而消失。</li>
<li><strong>持久性</strong>: 这些变量在整个程序运行期间都存在，并且可以跨函数访问。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>代码区</strong>（Text Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 代码区（又称文本区）存储程序的机器指令，即程序的代码部分。它是只读的，以防止程序在运行时意外修改自己的指令。</li>
<li><strong>特点</strong>:<ul>
<li><strong>只读</strong>: 通常代码区是不可写的，防止修改代码。</li>
<li><strong>共享性</strong>: 代码区可以在多线程或多进程之间共享，比如多个进程可以运行同一个可执行文件的不同实例，它们可以共享代码区。</li>
<li><strong>不可变性</strong>: 在程序运行时，代码区的数据（指令）不会改变。</li>
</ul>
</li>
</ul>
<p><strong>内存布局总结</strong></p>
<p>通常程序的内存布局可以按以下顺序从高地址到低地址分布：</p>
<ol>
<li><strong>栈区（Stack）</strong>: 由高地址向低地址增长。</li>
<li><strong>堆区（Heap）</strong>: 由低地址向高地址增长，动态分配的内存位于这里。</li>
<li><strong>BSS 区（BSS）</strong>: 存储未初始化的全局变量和静态变量，初始值为 0。</li>
<li><strong>数据区（Data）</strong>: 存储已初始化的全局变量和静态变量。</li>
<li><strong>代码区（Text）</strong>: 存储程序的代码，通常是只读的。</li>
</ol>
<h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><p>1.创建子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行一次fork，就会在原有的进程基础上创建一个新的子进程</span></span><br><span class="line"><span class="comment">//而且如果fork之后不区分父子进程的代码区，则后面所有的代码都会执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//fflush(stdout);</span></span><br><span class="line">	fork();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">   <span class="comment">// fflush(NULL);</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建区分主进程与子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork后区分父子进程</span></span><br><span class="line"><span class="comment">//使用fork()创建子进程标准代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());    <span class="comment">//一定是父进程打印的</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork创建进程错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:子进程正在工作...\n&quot;</span>,getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:父进程正在工作...\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%d]End!\n&quot;</span>,getpid());</span><br><span class="line">   <span class="comment">//  getchar();</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证系统进程调度方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     pid=fork();</span><br><span class="line">     <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]子进程正在运行中....\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程i=====%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]父进程正在运行中....\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程k=====%d\n&quot;</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.父进程拥有独立的地址空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父子进程拥有独立的地址空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">10</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程的代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程....\n&quot;</span>);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        z++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>, x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程的代码区</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>, x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/7.png"></p>
<p>4.子进程继承父进程的空间,</p>
<p>   子进程会继承父进程的一些公有的区域,比如磁盘空间，内核空间。文件描述符的偏移量保存在内核空间中,所以父进程改变偏移量,则子进程获取的偏移量是改变之后的.所以子进程继承父进程的空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子进程会继承父进程的一些公有的区域。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd=open(<span class="string">&quot;myfile.txt&quot;</span>,O_RDONLY))==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file fail...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork fail....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程....\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">32</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(read(fd,buffer,<span class="number">20</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read file fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buffer=[%s]\n&quot;</span>,buffer);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;子进程....\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">32</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(read(fd,buffer,<span class="number">20</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read file fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buffer=[%s]\n&quot;</span>,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果图:</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/8.png"></p>
<h2 id="进程sleep-睡眠状态"><a href="#进程sleep-睡眠状态" class="headerlink" title="进程sleep 睡眠状态"></a>进程sleep 睡眠状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能：进程在一定的时间内没有任何动作，称为进程的挂起（进程处于等待态）</span><br><span class="line">参数：</span><br><span class="line">seconds：指定要挂起的秒数</span><br><span class="line">返回值：</span><br><span class="line">若进程挂起到second指定的时间则返回<span class="number">0</span>，若有信号中断则返回剩余秒数</span><br><span class="line">注意：</span><br><span class="line">进程挂起指定的秒数后程序并不会立即执行，系统只是将此进程切换到就绪态</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        <span class="comment">//当运行到sleep函数后，程序会在此位置等待设定的秒数，当秒数到达后，代码会接着执行</span></span><br><span class="line">        <span class="comment">//sleep运行时进程为等待态，时间到达后会先切换到就绪态，如果代码继续运行，再切换到运行态</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程的等待wait函数"><a href="#进程的等待wait函数" class="headerlink" title="进程的等待wait函数"></a><strong>进程的等待wait函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。调用wait函数的进程会挂起，直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒。若调用进程没有子进程或它的子进程已经结束，该函数立即返回。</span><br><span class="line">    </span><br><span class="line">参数：status：函数返回时，参数status中包含子进程退出时的状态信息。子进程的退出信息在一个<span class="type">int</span>中包含了多个字段，用宏定义可以取出其中的每个字段。子进程可以通过<span class="built_in">exit</span>或者_exit函数发送退出状态。</span><br><span class="line">    </span><br><span class="line">返回值：</span><br><span class="line">	成功：子进程的进程号。</span><br><span class="line">	失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> <code>WIFEXITED(status)</code>：取出子进程的退出信息。</p>
<p>​	如果子进程是正常终止的，取出的字段值非零。 </p>
<p><code>WEXITSTATUS(status)</code>：返回子进程的退出状态。</p>
<p>​	返回子进程的退出状态，退出状态保存在status变量的8~16位。 在用此宏前应先用宏WIFEXITED判断子进程是否正常退出，正常退出才可以使用此宏。 </p>
<p><strong>注意</strong>： 此status是wait的参数指向的整型变量。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	if(pid&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;进程创建失败&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	if(pid == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		for(i=0;i&lt;3;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;子进程\n&quot;);</span><br><span class="line">			sleep(1);</span><br><span class="line">		&#125;</span><br><span class="line">		//使用exit退出当前进程并设置退出状态</span><br><span class="line">		exit(3);</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		//使用wait在父进程中阻塞等待子进程的退出</span><br><span class="line">		//不接收子进程的退出状态</span><br><span class="line">		//wait(NULL);</span><br><span class="line">		//接收子进程的退出状态，子进程中必须使用exit或者_exit函数退出进程是发送退出状态</span><br><span class="line">		int status = 0;</span><br><span class="line">		wait(&amp;status);</span><br><span class="line">		if(WIFEXITED(status) != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;子进程返回状态: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;父进程\n&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status,<span class="type">int</span> options)</span></span><br><span class="line">功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">pid：指定的进程或者进程组</span><br><span class="line">	pid&gt;0：等待进程ID等于pid的子进程。</span><br><span class="line">	pid=<span class="number">0</span>：等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会等待它。</span><br><span class="line">	pid=‐<span class="number">1</span>：等待任一子进程，此时waitpid和wait作用一样。</span><br><span class="line">	pid&lt;‐<span class="number">1</span>：等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值</span><br><span class="line">status：保存子进程退出时的状态信息</span><br><span class="line">options：选项</span><br><span class="line">	<span class="number">0</span>：同wait，阻塞父进程，等待子进程退出。</span><br><span class="line">	WNOHANG：没有任何已经结束的子进程，则立即返回。非阻塞形式</span><br><span class="line">	WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（跟踪调试，很少用到）</span><br><span class="line">返回值：</span><br><span class="line">	成功：返回状态改变了的子进程的进程号；如果设置了选项WNOHANG并且pid指定的进程存在则返回<span class="number">0</span>。</span><br><span class="line">	失败：返回‐<span class="number">1</span>。当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</span><br><span class="line">wait(status) &lt;==&gt; waitpid(‐<span class="number">1</span>, status, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;子进程\n&quot;</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;		</span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;父进程\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>僵尸进程</strong> : 进程已经结束,但进程的占用的资源未被回收,这样的进程称为僵尸进程.子进程已经运行结束,父进程未调用<code>wait</code>或<code>waitpid</code>函数回收子进程的资源使子进程变为僵尸进程的原因.</p>
</li>
<li><p><strong>孤儿进程</strong>:父进程运行结束,但子进程未运行结束的子进程.</p>
</li>
<li><p><strong>守护进程</strong>:守护进程是个特殊的孤儿进程,这种进程脱离终端,在后台运行.</p>
</li>
</ul>
<h2 id="进程的终止exit-exit"><a href="#进程的终止exit-exit" class="headerlink" title="进程的终止exit&#x2F;_exit"></a><strong>进程的终止exit&#x2F;_exit</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">	一般失败退出设置为非<span class="number">0</span>;成功退出设置为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>_exit函数</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">一般失败退出设置为非<span class="number">0</span>,成功退出设置为<span class="number">0</span></span><br><span class="line"><span class="number">8</span> 返回值：</span><br><span class="line"><span class="number">9</span> 无</span><br></pre></td></tr></table></figure>

<p>exit和_exit函数的区别： </p>
<p>exit为库函数，而_exit为系统调用 </p>
<p>exit会刷新缓冲区，但是_exit不会刷新缓冲区 </p>
<p>一般会使用exit  </p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/9.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BBB\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CCC\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;AAA\n&quot;</span>);</span><br><span class="line">   fun();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;DDD\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>return 除了返回值以外,在主函数中可以退出进程,但是在子函数中使用只能退出当前函数.</p>
<p>exit(0) 可以退出一个进程,且可以刷新缓冲区.</p>
<p>_exit(0) 可以退出一个进程,但是不会刷新缓冲区.</p>
<h2 id="进程退出清理atexit"><a href="#进程退出清理atexit" class="headerlink" title="进程退出清理atexit"></a><strong>进程退出清理</strong>atexit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br><span class="line">功能: 注册进程正常结束前调用的函数,进程退出执行注册函数.</span><br><span class="line">参数: function: 进程结束前,调用函数的入口地址.</span><br><span class="line">    一个进程中可以多次调用atexit函数注册清理函数.</span><br><span class="line">    正常结束前调用函数的顺序和注册时的顺序相反.</span><br><span class="line">返回值:</span><br><span class="line">   成功: <span class="number">0</span></span><br><span class="line">   失败: 非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clear fun1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clear fun2...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clear fun3...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//atexit函数在进程结束时,才会去执行参数对应的回调函数.</span></span><br><span class="line">    atexit(fun1);</span><br><span class="line">    atexit(fun2);</span><br><span class="line">    atexit(fun3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****************\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while(1)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程的创建–vfork函数"><a href="#进程的创建–vfork函数" class="headerlink" title="进程的创建–vfork函数"></a><strong>进程的创建–vfork函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:vfork函数和fork函数一样都是在已有的进程中创建一个新的进程,但是它们创建的子进程是有区别的.vfork保证子进程先运行,在它调用exec,<span class="built_in">exit</span>或者正常结束之后,父进程才可能被调度运行.</span><br><span class="line">参数: 无</span><br><span class="line">返回值:</span><br><span class="line">  成功:  子进程中返回<span class="number">0</span>, 父进程中返回子进程ID</span><br><span class="line">  失败:  <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     <span class="comment">//使用vfork函数创建子进程</span></span><br><span class="line">     pid=vfork();</span><br><span class="line">     <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;子进程创建失败...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程在运行中...\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//父进程代码区</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程运行中....\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子进程和父进程共享同一块空间-vfork创建"><a href="#子进程和父进程共享同一块空间-vfork创建" class="headerlink" title="子进程和父进程共享同一块空间(&#x3D;vfork创建)"></a><strong>子进程和父进程共享同一块空间(&#x3D;vfork创建)</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork创建</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> y=<span class="number">10</span>;</span><br><span class="line">     <span class="type">int</span> z=<span class="number">10</span>;</span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     pid=fork();</span><br><span class="line">     <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程的代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程....\n&quot;</span>);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        z++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>,x,y,z);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//子进程的代码区</span></span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;子进程...\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>,x,y,z);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vfork创建</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> y=<span class="number">200</span>;</span><br><span class="line">     <span class="type">int</span> z=<span class="number">300</span>;</span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     <span class="comment">//子进程会复制父进程fork之前的所有内容,但是fork之后,父子进程完全独立,所以不管双方怎么改变(堆区,栈区,数据区),都不会影响对方</span></span><br><span class="line">     pid=vfork();</span><br><span class="line">     <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;创建进程失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程的代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程正在运行中...\n&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x==%d,y==%d,z==%d\n&quot;</span>,x,y,z);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//子进程的代码区</span></span><br><span class="line">       </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;子进程正在运行中...\n&quot;</span>);</span><br><span class="line">           x++;</span><br><span class="line">           y++;</span><br><span class="line">           z++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x==%d,y==%d,z==%d\n&quot;</span>,x,y,z);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="vfork-与-fork的区别"><a href="#vfork-与-fork的区别" class="headerlink" title="vfork 与 fork的区别"></a>vfork 与 fork的区别</h2><p><code>vfork()</code> 和 <code>fork()</code> 都是用于创建子进程的系统调用，但它们之间有一些重要的区别，特别是在父进程和子进程之间共享内存空间的情况上。以下是两者的区别：</p>
<ol>
<li><p><strong>内存空间</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li><code>fork()</code> 创建一个新的子进程，子进程拥有父进程的<strong>完整拷贝</strong>，包括内存地址空间、文件描述符等。</li>
<li>在现代操作系统中，<code>fork()</code> 通常使用 <strong>写时拷贝</strong> (copy-on-write) 机制，即只有当父子进程中的某一方修改数据时，操作系统才会为子进程创建该数据的副本。这减少了不必要的内存开销。</li>
<li>因此，子进程最初看似共享父进程的内存空间，但实际上两者是独立的，只有在数据发生变化时才分开。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li><code>vfork()</code> 主要用于优化性能。与 <code>fork()</code> 不同的是，<code>vfork()</code> 不会立即复制父进程的内存空间。子进程会<strong>直接共享父进程的地址空间</strong>，直到子进程调用 <code>exec()</code> 或 <code>exit()</code>。</li>
<li>在 <code>vfork()</code> 之后、调用 <code>exec()</code> 或 <code>exit()</code> 之前，父进程会被阻塞，等待子进程完成。因为子进程和父进程共享同一个地址空间，子进程对内存的修改会直接影响父进程。</li>
<li>这种行为带来了一些风险：如果子进程在调用 <code>exec()</code> 或 <code>exit()</code> 之前修改了内存内容，父进程的数据可能会被破坏。因此，使用 <code>vfork()</code> 时要小心，避免在子进程中执行不安全的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li>由于 <code>fork()</code> 创建了父进程内存空间的副本，尽管使用了写时拷贝技术，其开销还是比 <code>vfork()</code> 大一些，尤其是在内存较大的进程中。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li><code>vfork()</code> 的性能更好，因为它不需要复制父进程的内存空间。子进程直接使用父进程的内存，因此减少了内存和CPU的开销。</li>
<li>这种方式在创建短时间内就要调用 <code>exec()</code> 的子进程时非常高效。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>执行顺序</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li>在 <code>fork()</code> 之后，父进程和子进程是独立执行的，谁先执行取决于调度器。父进程并不会等待子进程。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li>在 <code>vfork()</code> 之后，父进程会被阻塞，直到子进程调用 <code>exec()</code> 或 <code>exit()</code> 完成。这样确保了子进程优先执行，而父进程不会在子进程完成之前继续运行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li>适合需要在父子进程中保持独立内存空间的情况，尤其是当子进程需要继续运行而不立即执行新程序时。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li>适合性能敏感的场景，特别是在创建子进程后马上调用 <code>exec()</code> 执行新程序的场合。避免了不必要的内存拷贝。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>fork()</code>：子进程和父进程在创建时拥有独立的内存空间，虽然初始状态下看起来共享，但修改时内存会被复制，属于“写时拷贝”。</li>
<li><code>vfork()</code>：子进程在调用 <code>exec()</code> 或 <code>exit()</code> 之前，和父进程共享同一个内存空间，使用时要小心，防止子进程修改父进程的数据。</li>
</ul>
<h2 id="进程的替换exec"><a href="#进程的替换exec" class="headerlink" title="进程的替换exec"></a><strong>进程的替换exec</strong></h2><p>exec函数族，是由六个exec函数组成的。 </p>
<ul>
<li><p>exec函数族提供了六种在进程中启动另一个程序的方法。 </p>
</li>
<li><p>exec函数族可以根据指定的文件名或目录名找到可执行文件。 </p>
</li>
<li><p>调用exec函数的进程并不创建新的进程，故调用exec前后，进程的进程号并不会改变，其执行的程序完全由新的程序替换，而新程序则从其main函数开始执行。</p>
</li>
</ul>
<p>exec函数族取代调用进程的数据段、代码段和堆栈段</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/10.png"></p>
<p>一个进程调用exec后，除了进程ID，进程还保留了下列特征不变： </p>
<p>​	父进程号、进程组号 、控制终端、根目录、当前工作目录、进程信号屏蔽集、未处理信号</p>
<p><strong>exec函数族</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL*/</span>, <span class="type">char</span> * <span class="type">const</span> envp[] )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：在一个进程里面执行另一个程序，主要用于执行命令<br><strong>参数</strong>：</p>
<ul>
<li><p>path：命令或者程序的路径</p>
</li>
<li><p>l：如果是带l的函数，对应的命令或者程序是通过每一个参数进行传递的，最后一个为NULL表示结束。例如：<code>&quot;ls&quot;, &quot;‐l&quot;, NULL</code></p>
</li>
<li><p>v:如果是带v的函数，对应的命令或者程序是通过一个指针数组来传递的，指针数组的最后一个元素为NULL标识结束。例如：<code>char *str[] = &#123;&quot;ls&quot;, &quot;‐l&quot;, NULL&#125;;</code></p>
</li>
<li><p>p：如果是不带p的函数，第一个参数必须传当前命令或者程序的绝对路径，如果是带p的函数，第一个参数既可以是绝对路径，也可以是相对路径</p>
</li>
<li><p>e:  允许你传递一个自定义的环境变量数组（<code>envp[]</code>），因此可以为新程序指定不同于当前进程的环境变量。自定义的环境变量数组 <code>envp[]</code> 使得你可以在调用 <code>execve()</code> 或 <code>execvpe()</code> 时，为新进程传递特定的环境变量。通过这种方式，你能够控制新程序的运行环境，与当前进程的环境隔离开来。这在需要运行特定环境设置的子进程时非常有用。</p>
</li>
</ul>
<p><strong>返回值</strong>：成功：1；失败：‐1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1.</span></span><br><span class="line"> <span class="comment">//调用exec函数族中的函数，执行其他命令或者程序</span></span><br><span class="line"> <span class="comment">//查看命令的路径：whereis 命令或者which 命令</span></span><br><span class="line"> <span class="comment">//exec函数族可以调用shell命令</span></span><br><span class="line"> <span class="comment">//不带p的函数，命令的路径一定要用绝对路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程在运行中\n&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程运行结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程运行中\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execl&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">第二种方式:</span><br><span class="line"> <span class="comment">//带p的函数，第一个参数既可以是相对路径，也可以是绝对路径</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execlp&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">第三种方式:</span><br><span class="line"><span class="comment">//带v的函数需要使用指针数组来传递</span></span><br><span class="line">    <span class="type">char</span> *str[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(execv(<span class="string">&quot;/bin/ls&quot;</span>, str) == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         perror(<span class="string">&quot;fail to execv&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> 第四种方式:</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//***************exec函数族调用可执行文件******************     </span></span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">&quot;./hello&quot;</span>, <span class="string">&quot;./hello&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execlp&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">第五种方式:</span><br><span class="line">   <span class="comment">//***************exec函数族调用shell脚本******************       </span></span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">&quot;./myshell.sh&quot;</span>, <span class="string">&quot;./myshell.sh&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execl&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">2</span></span><br><span class="line">print_env.c:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;USER: %s\n&quot;</span>, getenv(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH: %s\n&quot;</span>, getenv(<span class="string">&quot;PATH&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execve.c:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;./print_env&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[] = &#123;</span><br><span class="line">        <span class="string">&quot;USER=custom_user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PATH=/custom/path&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;./print_env&quot;</span>, args, envp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 execve 执行成功，下面的代码不会被执行</span></span><br><span class="line">    perror(<span class="string">&quot;execve failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">通过gcc print_env.c -o print_env 创建可执行文件后，运行execve.c</span><br></pre></td></tr></table></figure>

<h2 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a><strong>system函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br><span class="line">功能：执行一个shell命令（shell命令、可执行文件、shell脚本）</span><br><span class="line">system会调用fork函数产生子进程，</span><br><span class="line">子进程调用exec启动/bin/sh ‐c <span class="built_in">string</span></span><br><span class="line">来执行参数<span class="built_in">string</span>字符串所代表的命令，</span><br><span class="line">此命令执行完后返回原调用进程</span><br><span class="line">参数：</span><br><span class="line">	command：要执行的命令的字符串</span><br><span class="line">返回值：</span><br><span class="line">	如果command为<span class="literal">NULL</span>，则system()函数返回非<span class="number">0</span>，一般为<span class="number">1</span>。</span><br><span class="line">	如果system()在调用/bin/sh时失败则返回<span class="number">127</span>，其它失败原因返回‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //使用system执行shell命令</span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    system(&quot;ls -l&quot;);</span><br><span class="line">    system(&quot;./myhello&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="system-与-exec-的区别与相同点"><a href="#system-与-exec-的区别与相同点" class="headerlink" title="system 与 exec 的区别与相同点"></a>system 与 exec 的区别与相同点</h3><p><code>system()</code> 和 <code>exec()</code> 系列函数都是用于在 C 程序中执行外部命令或程序的函数，但它们在行为、功能和用途上有显著的区别。以下是两者的区别和相同点：</p>
<p><strong>相同点</strong></p>
<ol>
<li><p><strong>执行外部命令或程序</strong>：</p>
<ul>
<li>两者都可以用于执行外部的命令或程序。例如，调用 shell 命令、运行可执行文件等。</li>
</ul>
</li>
<li><p><strong>基于操作系统的函数</strong>：</p>
<ul>
<li><code>system()</code> 和 <code>exec()</code> 都是操作系统提供的函数，它们的行为依赖于操作系统的实现。</li>
</ul>
</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li><p><strong>执行方式</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li><code>system()</code> 会调用一个 shell 来执行指定的命令。它首先创建一个新的子进程，然后在该子进程中执行 shell 命令。执行完命令后，子进程会终止，父进程会等待子进程结束并返回其退出状态。</li>
<li><code>system()</code> 函数会阻塞父进程的执行，直到命令执行完毕。<ul>
<li><code>system()</code> 返回值是子进程的退出状态，如果命令执行失败，返回值可能是 -1。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li><p><code>exec()</code> 系列函数不调用 shell，而是直接用指定的程序替换当前进程的映像。这意味着调用 <code>exec()</code> 后，当前进程的代码和数据会被新程序的代码和数据替代，不再返回到调用 <code>exec()</code> 的代码中。</p>
</li>
<li><p><code>exec()</code> 不会创建新进程，而是在当前进程中直接加载并执行新程序。</p>
</li>
<li><p><code>exec()</code> 系列有多个变体（如 <code>execl()</code>, <code>execv()</code>, <code>execvp()</code> 等），用于根据不同的需求传递参数。无论使用哪个变体，<code>exec()</code> 都不会返回，除非发生错误。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程关系</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li><code>system()</code> 创建一个新的子进程执行命令，而父进程保持不变。子进程完成后，父进程会继续执行原来的代码。</li>
<li>父进程和子进程之间没有共享数据，子进程完成任务后就会退出。</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li><code>exec()</code> 不创建子进程，而是用新程序替换当前进程。调用 <code>exec()</code> 的进程会直接被新程序替代，不再返回。由于没有创建新进程，因此调用 <code>exec()</code> 后，当前进程的进程 ID 不变，但执行的代码已经是新程序的内容。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li>适合简单地调用外部命令或脚本，且希望父进程在子进程执行完毕后继续执行的场景。</li>
<li>例如：在程序中调用 shell 脚本或系统命令，并等待其完成后继续执行后续代码。</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li>适合用当前进程执行另一个程序的场景，特别是当你不再需要执行当前进程的代码时。</li>
<li>常见用法是在 <code>fork()</code> 之后调用 <code>exec()</code>，子进程调用 <code>exec()</code> 来执行新程序，而父进程继续执行其他任务。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回行为</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li><code>system()</code> 执行完命令后会返回，返回值是命令的退出状态，因此父进程可以检查命令的执行结果。</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li><code>exec()</code> 函数不会返回，除非发生错误。如果执行成功，当前进程被新程序替换；如果失败，<code>exec()</code> 会返回 -1，并设置 <code>errno</code> 以指示错误原因。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>system()</code>：在子进程中执行外部命令，父进程等待子进程完成并返回退出状态。适合简单的命令执行场景。</li>
<li><code>exec()</code>：用新程序替换当前进程，不会返回。适合需要完全替换当前进程执行另一个程序的场景。</li>
</ul>
<p>如果你的任务是执行一个命令并继续当前程序的运行，使用 <code>system()</code> 更方便；如果你需要完全替换当前进程为另一个程序，使用 <code>exec()</code> 是更好的选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">MegaV</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux-C/">Linux, C</a></div><div class="post-share"><div class="social-share" data-image="/img/user.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/11/04/hello-world/" title="Hello hexo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Hello hexo</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1234$ hexo serveror$ hexo s  More info: Server Generate static files123$ hexo generateor$ hexo g  More info: Generating Deploy to remote sites123$ hexo deployor$ hexo d  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">MegaV</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mokovi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m1447687747@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">零碎知识小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC"><span class="toc-number">1.1.</span> <span class="toc-text">GCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">GCC的编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">GCC的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">GCC的主要特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POSIX%E6%A0%87%E5%87%86"><span class="toc-number">1.2.</span> <span class="toc-text">POSIX标准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">进程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%9B%E5%88%B6%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">进程的调度进制：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%88Round-Robin-Scheduling%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">时间片轮转调度（Round Robin Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88Priority-Scheduling%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">优先级调度（Priority Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%EF%BC%88CFS%EF%BC%8CCompletely-Fair-Scheduling%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">完全公平调度（CFS，Completely Fair Scheduling）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CFS%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">CFS实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">进程控制块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">3.1.</span> <span class="toc-text">进程号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BAfork%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">进程的创建fork函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">3.3.</span> <span class="toc-text">程序区域划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">创建子进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bsleep-%E7%9D%A1%E7%9C%A0%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.</span> <span class="toc-text">进程sleep 睡眠状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85wait%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">进程的等待wait函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">waitpid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2exit-exit"><span class="toc-number">3.8.</span> <span class="toc-text">进程的终止exit&#x2F;_exit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E6%B8%85%E7%90%86atexit"><span class="toc-number">3.9.</span> <span class="toc-text">进程退出清理atexit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E2%80%93vfork%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">进程的创建–vfork函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4-vfork%E5%88%9B%E5%BB%BA"><span class="toc-number">3.11.</span> <span class="toc-text">子进程和父进程共享同一块空间(&#x3D;vfork创建)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vfork-%E4%B8%8E-fork%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.</span> <span class="toc-text">vfork 与 fork的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9B%BF%E6%8D%A2exec"><span class="toc-number">3.13.</span> <span class="toc-text">进程的替换exec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system%E5%87%BD%E6%95%B0"><span class="toc-number">3.14.</span> <span class="toc-text">system函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system-%E4%B8%8E-exec-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">3.14.1.</span> <span class="toc-text">system 与 exec 的区别与相同点</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux C学习笔记">Linux C学习笔记</a><time datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/04/hello-world/" title="Hello hexo">Hello hexo</a><time datetime="2024-11-04T12:51:49.686Z" title="Created 2024-11-04 20:51:49">2024-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By MegaV</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>