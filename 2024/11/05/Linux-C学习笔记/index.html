<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux C学习笔记 | MegaV的博客</title><meta name="author" content="MegaV"><meta name="copyright" content="MegaV"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux C学习笔记">
<meta property="og:url" content="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MegaV的博客">
<meta property="og:description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/user.jpg">
<meta property="article:published_time" content="2024-11-05T11:33:22.000Z">
<meta property="article:modified_time" content="2024-11-05T12:57:23.643Z">
<meta property="article:author" content="MegaV">
<meta property="article:tag" content="Linux, C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/user.jpg"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux C学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-05 20:57:23',
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MegaV的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux C学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Linux C学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-05T12:57:23.643Z" title="Updated 2024-11-05 20:57:23">2024-11-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零碎知识小结"><a href="#零碎知识小结" class="headerlink" title="零碎知识小结"></a>零碎知识小结</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。</p>
<h3 id="GCC的编译过程"><a href="#GCC的编译过程" class="headerlink" title="GCC的编译过程"></a>GCC的编译过程</h3><p>程序的编译过程可以分为四个主要阶段：</p>
<ol>
<li><p><strong>预编译</strong>：该阶段进行宏替换、删除注释、头文件包含以及条件编译等操作，生成一个预处理文件（<code>.i</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编译</strong>：将预处理后的<code>.i</code>文件编译成汇编文件（<code>.s</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>汇编</strong>：将汇编文件转换为二进制目标文件（<code>.o</code>），即机器代码。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>链接</strong>：将目标文件与库函数和启动代码链接，生成最终的可执行文件（通常是<code>a.out</code>，或在Windows下为<code>a.exe</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的使用方式"><a href="#GCC的使用方式" class="headerlink" title="GCC的使用方式"></a>GCC的使用方式</h3><ol>
<li><p><strong>一步到位的编译</strong>：<br>默认情况下，GCC会将源代码直接编译成一个可执行文件<code>a.out</code>。</p>
<ul>
<li>编译并生成可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure></li>
<li>运行程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure></li>
<li>指定输出文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o myhello</span><br><span class="line">./myhello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分步编译</strong>：<br>编译过程可以分为多个步骤进行，每个步骤都可以单独执行：</p>
<ul>
<li>预处理：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
<li>编译：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
<li>汇编：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
<li>链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>警告信息</strong>：<br>使用<code>-Wall</code>选项可以查看编译时的警告信息，有助于排除潜在的代码问题。</p>
<ul>
<li>编译并显示警告：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -Wall</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的主要特点"><a href="#GCC的主要特点" class="headerlink" title="GCC的主要特点"></a>GCC的主要特点</h3><ul>
<li><strong>多语言支持</strong>：GCC支持C、C++、Fortran、Ada、Go、Objective-C、D等多种编程语言。</li>
<li><strong>优化能力</strong>：GCC提供多种优化选项，如<code>-O2</code>、<code>-O3</code>等，帮助提升代码执行效率。</li>
<li><strong>跨平台支持</strong>：GCC支持多个操作系统和平台，如Linux、Windows、macOS、ARM等。</li>
<li><strong>标准化支持</strong>：GCC支持各种语言标准，特别是C和C++的最新标准。</li>
<li><strong>调试支持</strong>：GCC与调试器（如GDB）集成，提供调试功能。</li>
</ul>
<p>总结来说，GCC是一个强大的、开源的编译工具，适用于多种编程语言，并提供了丰富的优化和调试功能，广泛应用于各种开发场景。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>POSIX（Portable Operating System Interface，便携式操作系统接口）是由 <strong>IEEE</strong>（美国电气和电子工程师协会）开发的一系列标准，这些标准定义了操作系统的应用程序接口（API），旨在提高应用程序在不同操作系统上的可移植性。</p>
<h3 id="1-POSIX-标准涵盖的内容"><a href="#1-POSIX-标准涵盖的内容" class="headerlink" title="1. POSIX 标准涵盖的内容"></a>1. <strong>POSIX 标准涵盖的内容</strong></h3><p>POSIX 标准定义了与操作系统交互的一系列接口，包括但不限于以下方面：</p>
<ul>
<li><strong>进程管理</strong>：进程的创建、终止、进程组、信号、线程等。</li>
<li><strong>输入输出（I&#x2F;O）</strong>：文件的读写操作、文件描述符、文件系统的访问权限等。</li>
<li><strong>进程间通信（IPC）</strong>：如管道（pipe）、消息队列、共享内存、信号量等。</li>
<li><strong>线程</strong>：POSIX 线程（pthreads），定义了多线程编程的 API。</li>
<li><strong>设备接口</strong>：访问硬件设备的接口，如文件 I&#x2F;O 和终端设备。</li>
<li><strong>网络编程</strong>：POSIX 包含对套接字（socket）等网络编程的支持。</li>
<li><strong>标准 C 库函数</strong>：一些常见的 C 语言库函数，如 <code>fork</code>、<code>exec</code>、<code>read</code>、<code>write</code> 等都在 POSIX 标准内。</li>
</ul>
<h3 id="2-POSIX-的不同标准部分"><a href="#2-POSIX-的不同标准部分" class="headerlink" title="2. POSIX 的不同标准部分"></a>2. <strong>POSIX 的不同标准部分</strong></h3><p>POSIX 是由多个子标准组成的，涵盖了不同方面的功能，常见的有：</p>
<ul>
<li><strong>POSIX.1</strong>：定义基本的操作系统 API，包括文件系统操作、进程控制、信号处理等。</li>
<li><strong>POSIX.1b</strong>：定义了实时扩展功能，包括定时器、优先级调度、信号量等。</li>
<li><strong>POSIX.1c</strong>：定义了线程接口（POSIX 线程，即 <code>pthreads</code>）。</li>
<li><strong>POSIX.2</strong>：定义了命令行解释器（shell）和一些标准工具及命令，如 <code>ls</code>、<code>grep</code>、<code>sed</code> 等。</li>
</ul>
<h3 id="3-POSIX-的实际应用"><a href="#3-POSIX-的实际应用" class="headerlink" title="3. POSIX 的实际应用"></a>3. <strong>POSIX 的实际应用</strong></h3><ul>
<li><strong>UNIX 和类 UNIX 系统</strong>：POSIX 标准的主要目的是为了兼容 UNIX 系统，因此大多数 UNIX 和类 UNIX 系统都支持 POSIX，包括 Linux、macOS、Solaris、FreeBSD 等。</li>
<li><strong>Windows</strong>：虽然 Windows 并不是 UNIX 系统，但通过特定的兼容层（例如 Windows Subsystem for Linux (WSL)）也能支持部分 POSIX API。</li>
<li><strong>嵌入式系统</strong>：某些嵌入式操作系统也部分支持 POSIX API，提升嵌入式开发的便携性。</li>
</ul>
<p><strong>总结：</strong></p>
<p>POSIX 标准为操作系统提供了一组标准化的接口，旨在提高程序的跨平台可移植性。它定义了多种操作系统功能的 API，包括文件系统、进程控制、线程、信号处理、进程间通信等。通过遵循 POSIX，开发者可以编写适用于多个操作系统的可移植软件。</p>
<hr>
<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p><strong>1.程序和进程的区别：</strong> </p>
<p>​	<strong>程序：是静态的，存放在磁盘上的可执行文件</strong> </p>
<p>​	<strong>进程：是动态的，是运行在内存中的程序的执行实例</strong></p>
<p>​	程序是一些指令的有序集合，而进程是程序执行的过程，进程是程序的一次执行过程。 进程的状态是变化的，其包括进程的创建、调度和消亡。 当程序运行时，其就是进程，程序每运行一次，就会创建一个进程。在linux系统中，进程是管理事务的基本单元。 进程拥有自己独立的处理环境和系统资源（处理器、存储器、I&#x2F;O设备、数据、程序）。</p>
<p><strong>2.进程的状态及转换</strong></p>
<p>进程整个生命周期可以简单划分为<strong>三种状态</strong>： </p>
<p>​	<strong>就绪态：</strong> 进程已经具备执行的一切条件，正在等待分配CPU的处理时间。 </p>
<p>​	<strong>执行态：</strong> 该进程正在占用CPU运行。 </p>
<p>​	<strong>等待态：</strong> 进程因不具备某些执行条件而暂时无法继续执行的状态。</p>
<p><strong>进程三个状态的转换关系</strong></p>
<p>![](E:&#x2F;study&#x2F;培训班&#x2F;资料&#x2F;4-Linux c&#x2F;2-Linux c&#x2F;Linux C高级编程.assets&#x2F;1.png)</p>
<p>引起进程状态转换的具体原因如下：</p>
<p>​	<strong>运行态→等待态</strong>：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>​	<strong>等待态→就绪态</strong>：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>​	<strong>运行态→就绪态</strong>：运行时间片到；出现有更高优先权进程。</p>
<p>​	<strong>就绪态—→运行态</strong>：CPU 空闲时选择一个就绪进程</p>
<h2 id="进程的调度进制："><a href="#进程的调度进制：" class="headerlink" title="进程的调度进制："></a><strong>进程的调度进制：</strong></h2><p>​	时间片轮转，上下文切换。多进程不是说一个进程执行完再执行另一个进程，而是交替执行的，一个进程执行一 </p>
<p>段时间，然后下一个进程在执行一段时间，依次类推，所有进程执行完之后再回到第一个进程继续执行由此类推.</p>
<p>在操作系统中，时间片轮转调度（Round Robin Scheduling）、优先级调度（Priority Scheduling）和完全公平调度（Completely Fair Scheduling，CFS）是三种常见的进程调度算法。</p>
<h3 id="1-时间片轮转调度（Round-Robin-Scheduling）"><a href="#1-时间片轮转调度（Round-Robin-Scheduling）" class="headerlink" title="1. 时间片轮转调度（Round Robin Scheduling）"></a>1. <strong>时间片轮转调度（Round Robin Scheduling）</strong></h3><p><strong>概述</strong>：<br>时间片轮转调度是一种简单且常用的调度策略，特别适用于多任务环境中的时间共享系统。该策略的核心思想是为每个进程分配一个固定的时间片（Time Slice），当一个进程用完它的时间片后，操作系统会将其挂起，将CPU资源分配给下一个进程。所有的进程按顺序轮流执行，保证每个进程都能获得一定的CPU时间。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程按照固定的时间片执行，当时间片耗尽时，调度器会将进程切换出去，并将其状态保存，再选择下一个进程执行。</li>
<li>如果进程在其时间片内完成了任务，则该进程会被移除调度队列，继续执行下一个任务。</li>
<li>如果进程没有在时间片内完成，调度器会将其放回队列末尾，等待下次调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易实现，适用于多任务操作系统。</li>
<li>每个进程都可以得到公平的CPU时间。</li>
<li>特别适用于交互式任务，避免某些进程独占CPU时间。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果时间片设置得太小，频繁的上下文切换会增加开销。</li>
<li>不考虑进程的优先级，可能导致重要的进程在轮转时被延迟。</li>
<li>时间片的选择要合适，过大或过小都会影响系统性能。</li>
</ul>
<p><strong>应用场景</strong>：<br>适用于一般的桌面操作系统和基于时间共享的系统，如Linux和Windows中的用户进程调度。</p>
<h3 id="2-优先级调度（Priority-Scheduling）"><a href="#2-优先级调度（Priority-Scheduling）" class="headerlink" title="2. 优先级调度（Priority Scheduling）"></a>2. <strong>优先级调度（Priority Scheduling）</strong></h3><p><strong>概述</strong>：<br>优先级调度是一种基于优先级的调度算法。每个进程都被分配一个优先级值，调度器总是选择优先级最高的进程来执行。高优先级进程会优先于低优先级进程执行，直到它完成或者被阻塞为止。优先级可以是静态的（在进程创建时确定），也可以是动态的（在运行过程中根据进程的行为或外部因素调整）。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程有一个优先级，优先级可以由系统静态设定，或由用户和操作系统动态调整。</li>
<li>调度器选择队列中优先级最高的进程执行，如果多个进程优先级相同，则采用其他算法（如时间片轮转）来调度。</li>
<li>优先级调度可以是抢占式的，即当一个高优先级进程到达时，会抢占正在运行的低优先级进程；也可以是非抢占式的，即进程执行完一个时间片后才会进行调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可以确保高优先级的进程能及时得到执行，适合有不同重要性的任务。</li>
<li>对于实时任务或需要快速响应的进程非常有用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>饥饿问题（Starvation）</strong>：低优先级的进程可能长时间得不到执行，特别是在高优先级进程一直占用CPU时。</li>
<li>不适用于所有任务，因为它忽视了进程的执行时间和公平性。</li>
<li>动态优先级调整可能增加系统的复杂性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于实时操作系统或任务需要严格响应时间的系统。</li>
<li>比如嵌入式系统中的任务调度和硬实时系统。</li>
</ul>
<h3 id="3-完全公平调度（CFS，Completely-Fair-Scheduling）"><a href="#3-完全公平调度（CFS，Completely-Fair-Scheduling）" class="headerlink" title="3. 完全公平调度（CFS，Completely Fair Scheduling）"></a>3. <strong>完全公平调度（CFS，Completely Fair Scheduling）</strong></h3><p><strong>概述</strong>：<br>完全公平调度（CFS）是Linux操作系统默认的调度算法，旨在为每个进程提供一个“公平”的CPU时间。与时间片轮转调度不同，CFS不使用固定的时间片，而是使用进程的“虚拟运行时间”（<code>virtual runtime</code>，简称<code>vruntime</code>）来决定哪个进程应该运行。CFS的目标是让每个进程尽可能公平地获得CPU时间，而不是通过固定的时间片来分配资源。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程都有一个<code>vruntime</code>值，表示该进程消耗的CPU时间。当一个进程运行时，它的<code>vruntime</code>会增加。</li>
<li>CFS通过一个红黑树（Red-Black Tree）来管理可执行的进程，树的根节点是<code>vruntime</code>最小的进程，这意味着它会被优先执行。</li>
<li>进程的<code>vruntime</code>会根据其实际运行时间动态调整，长时间运行的进程会让出CPU，短时间运行的进程会被优先调度。</li>
<li>CFS没有固定的时间片，而是基于进程的<code>vruntime</code>来决定调度顺序，进程越公平，<code>vruntime</code>的增加就越慢，调度时得到的CPU时间就越多。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>公平性</strong>：CFS最大程度地保证了进程之间的公平性，每个进程根据其CPU消耗时间来动态调整调度顺序。</li>
<li><strong>灵活性</strong>：相比时间片轮转调度，CFS具有更高的灵活性，可以动态调整每个进程的CPU时间分配，避免了不必要的频繁上下文切换。</li>
<li><strong>低延迟</strong>：对交互式进程提供较低的调度延迟，因为它总是优先调度<code>vruntime</code>较小的进程。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性较高，调度机制依赖于红黑树的实现，可能会增加系统的开销。</li>
<li>对于一些实时应用来说，CFS可能不能提供足够的响应保证，因为它更注重公平性而非严格的实时性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于需要平衡性能和公平性的多任务操作系统，如Linux。CFS是Linux的默认调度算法，适合各种通用计算任务。</li>
<li>不适用于实时性要求较高的任务。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>时间片轮转调度</strong>：公平地分配CPU时间给每个进程，但没有考虑进程的重要性，可能导致大量的上下文切换。</li>
<li><strong>优先级调度</strong>：通过优先级来决定进程执行顺序，适用于有明确优先级的任务，但可能导致低优先级进程饥饿。</li>
<li><strong>完全公平调度（CFS）</strong>：通过<code>vruntime</code>来动态公平地调度进程，适用于大多数应用，提供了平衡的调度策略，避免了固定时间片的缺点。</li>
</ul>
<p>每种调度算法都有其适用场景，Linux使用CFS作为默认的调度算法，以平衡系统的响应性与公平性。</p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a><strong>进程控制块</strong></h2><p>​	<strong>进程控制块</strong>就是用于保存一个进程信息的结构体，又称之为<strong>PCB</strong>。OS是根据PCB来对并发执行的进程进行控制和管理的。系统在创建一个进程的时候会开辟 一段内存空间存放与此进程相关的PCB数据结构。 PCB是操作系统中最重要的记录型数据结构。PCB中记录了用于描述进程进展情况及控制进程运行所需的全部信息。 </p>
<p>​	PCB是进程存在的唯一标志，在Linux中PCB存放在task_struct结构体中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/src</span><br><span class="line">$ <span class="built_in">sudo</span> apt-get install ctags</span><br><span class="line"><span class="built_in">sudo</span> ctags -R</span><br><span class="line"></span><br><span class="line">查看结构体  vim -t task_struct</span><br></pre></td></tr></table></figure>

<p>​	调度数据 (进程的状态,标记优先级,调度策略等)</p>
<p>​	时间数据: 创建该进程的时间,在用户态的运行时间,在内核态的运行时间.</p>
<p>​	文件数据： 文件描述符表,内存数据,进程标识(进程号)</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">MegaV</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux-C/">Linux, C</a></div><div class="post-share"><div class="social-share" data-image="/img/user.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/11/04/hello-world/" title="Hello hexo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Hello hexo</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1234$ hexo serveror$ hexo s  More info: Server Generate static files123$ hexo generateor$ hexo g  More info: Generating Deploy to remote sites123$ hexo deployor$ hexo d  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">MegaV</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mokovi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m1447687747@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">零碎知识小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC"><span class="toc-number">1.1.</span> <span class="toc-text">GCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">GCC的编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">GCC的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">GCC的主要特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POSIX%E6%A0%87%E5%87%86"><span class="toc-number">1.2.</span> <span class="toc-text">POSIX标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-POSIX-%E6%A0%87%E5%87%86%E6%B6%B5%E7%9B%96%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. POSIX 标准涵盖的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-POSIX-%E7%9A%84%E4%B8%8D%E5%90%8C%E6%A0%87%E5%87%86%E9%83%A8%E5%88%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. POSIX 的不同标准部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-POSIX-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. POSIX 的实际应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">进程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%9B%E5%88%B6%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">进程的调度进制：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%88Round-Robin-Scheduling%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 时间片轮转调度（Round Robin Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88Priority-Scheduling%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 优先级调度（Priority Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%EF%BC%88CFS%EF%BC%8CCompletely-Fair-Scheduling%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 完全公平调度（CFS，Completely Fair Scheduling）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">进程控制块</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux C学习笔记">Linux C学习笔记</a><time datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/04/hello-world/" title="Hello hexo">Hello hexo</a><time datetime="2024-11-04T12:51:49.686Z" title="Created 2024-11-04 20:51:49">2024-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By MegaV</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>