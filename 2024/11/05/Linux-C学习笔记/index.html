<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux C学习笔记 | MegaV的博客</title><meta name="author" content="MegaV"><meta name="copyright" content="MegaV"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux C学习笔记">
<meta property="og:url" content="https://gamma.fra1.zeabur.app/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MegaV的博客">
<meta property="og:description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:locale">
<meta property="og:image" content="https://gamma.fra1.zeabur.app/img/user.jpg">
<meta property="article:published_time" content="2024-11-05T11:33:22.000Z">
<meta property="article:modified_time" content="2024-11-11T07:22:42.928Z">
<meta property="article:author" content="MegaV">
<meta property="article:tag" content="Linux, C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gamma.fra1.zeabur.app/img/user.jpg"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="https://gamma.fra1.zeabur.app/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux C学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-11 15:22:42',
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MegaV的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux C学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Linux C学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-11T07:22:42.928Z" title="Updated 2024-11-11 15:22:42">2024-11-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零碎知识小结"><a href="#零碎知识小结" class="headerlink" title="零碎知识小结"></a>零碎知识小结</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。</p>
<h3 id="GCC的编译过程"><a href="#GCC的编译过程" class="headerlink" title="GCC的编译过程"></a>GCC的编译过程</h3><p>程序的编译过程可以分为四个主要阶段：</p>
<ol>
<li><p><strong>预编译</strong>：该阶段进行宏替换、删除注释、头文件包含以及条件编译等操作，生成一个预处理文件（<code>.i</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编译</strong>：将预处理后的<code>.i</code>文件编译成汇编文件（<code>.s</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>汇编</strong>：将汇编文件转换为二进制目标文件（<code>.o</code>），即机器代码。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>链接</strong>：将目标文件与库函数和启动代码链接，生成最终的可执行文件（通常是<code>a.out</code>，或在Windows下为<code>a.exe</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的使用方式"><a href="#GCC的使用方式" class="headerlink" title="GCC的使用方式"></a>GCC的使用方式</h3><ol>
<li><p><strong>一步到位的编译</strong>：<br>默认情况下，GCC会将源代码直接编译成一个可执行文件<code>a.out</code>。</p>
<ul>
<li>编译并生成可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure></li>
<li>运行程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure></li>
<li>指定输出文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o myhello</span><br><span class="line">./myhello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分步编译</strong>：<br>编译过程可以分为多个步骤进行，每个步骤都可以单独执行：</p>
<ul>
<li>预处理：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
<li>编译：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
<li>汇编：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
<li>链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>警告信息</strong>：<br>使用<code>-Wall</code>选项可以查看编译时的警告信息，有助于排除潜在的代码问题。</p>
<ul>
<li>编译并显示警告：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -Wall</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的主要特点"><a href="#GCC的主要特点" class="headerlink" title="GCC的主要特点"></a>GCC的主要特点</h3><ul>
<li><strong>多语言支持</strong>：GCC支持C、C++、Fortran、Ada、Go、Objective-C、D等多种编程语言。</li>
<li><strong>优化能力</strong>：GCC提供多种优化选项，如<code>-O2</code>、<code>-O3</code>等，帮助提升代码执行效率。</li>
<li><strong>跨平台支持</strong>：GCC支持多个操作系统和平台，如Linux、Windows、macOS、ARM等。</li>
<li><strong>标准化支持</strong>：GCC支持各种语言标准，特别是C和C++的最新标准。</li>
<li><strong>调试支持</strong>：GCC与调试器（如GDB）集成，提供调试功能。</li>
</ul>
<p>总结来说，GCC是一个强大的、开源的编译工具，适用于多种编程语言，并提供了丰富的优化和调试功能，广泛应用于各种开发场景。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>​	POSIX（<strong>Portable Operating System Interface for Unix</strong>）标准是由IEEE（Institute of Electrical and Electronics Engineers）制定的一系列标准，旨在定义操作系统接口（如系统调用、库函数等），以确保不同Unix系统之间的兼容性和可移植性。POSIX标准主要关注Unix和类Unix操作系统（如Linux、macOS、AIX等）之间的兼容性和一致性，使得应用程序能够在不同的操作系统平台之间移植而不需要进行大量的修改。</p>
<hr>
<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p><strong>1.程序和进程的区别：</strong> </p>
<p>​	<strong>程序：是静态的，存放在磁盘上的可执行文件</strong> </p>
<p>​	<strong>进程：是动态的，是运行在内存中的程序的执行实例</strong></p>
<p>​	程序是一些指令的有序集合，而进程是程序执行的过程，进程是程序的一次执行过程。 进程的状态是变化的，其包括进程的创建、调度和消亡。 当程序运行时，其就是进程，程序每运行一次，就会创建一个进程。在linux系统中，进程是管理事务的基本单元。 进程拥有自己独立的处理环境和系统资源（处理器、存储器、I&#x2F;O设备、数据、程序）。</p>
<p><strong>2.进程的状态及转换</strong></p>
<p>进程整个生命周期可以简单划分为<strong>三种状态</strong>： </p>
<p>​	<strong>就绪态：</strong> 进程已经具备执行的一切条件，正在等待分配CPU的处理时间。 </p>
<p>​	<strong>执行态：</strong> 该进程正在占用CPU运行。 </p>
<p>​	<strong>等待态：</strong> 进程因不具备某些执行条件而暂时无法继续执行的状态。</p>
<p><strong>进程三个状态的转换关系</strong></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/1.png"></p>
<p>引起进程状态转换的具体原因如下：</p>
<p>​	<strong>运行态→等待态</strong>：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>​	<strong>等待态→就绪态</strong>：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>​	<strong>运行态→就绪态</strong>：运行时间片到；出现有更高优先权进程。</p>
<p>​	<strong>就绪态—→运行态</strong>：CPU 空闲时选择一个就绪进程</p>
<h2 id="进程的调度进制："><a href="#进程的调度进制：" class="headerlink" title="进程的调度进制："></a><strong>进程的调度进制：</strong></h2><p>​	多进程不是说一个进程执行完再执行另一个进程，而是交替执行的，一个进程执行一段时间，然后下一个进程在执行一段时间，依次类推，所有进程执行完之后再回到第一个进程继续执行由此类推。在操作系统中，时间片轮转调度（Round Robin Scheduling）、优先级调度（Priority Scheduling）和完全公平调度（Completely Fair Scheduling，CFS）是三种常见的进程调度算法。</p>
<h3 id="时间片轮转调度（Round-Robin-Scheduling）"><a href="#时间片轮转调度（Round-Robin-Scheduling）" class="headerlink" title="时间片轮转调度（Round Robin Scheduling）"></a><strong>时间片轮转调度（Round Robin Scheduling）</strong></h3><p><strong>概述</strong>：<br>    时间片轮转调度是一种简单且常用的调度策略，特别适用于多任务环境中的时间共享系统。该策略的核心思想是为每个进程分配一个固定的时间片（Time Slice），当一个进程用完它的时间片后，操作系统会将其挂起，将CPU资源分配给下一个进程。所有的进程按顺序轮流执行，保证每个进程都能获得一定的CPU时间。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程按照固定的时间片执行，当时间片耗尽时，调度器会将进程切换出去，并将其状态保存，再选择下一个进程执行。</li>
<li>如果进程在其时间片内完成了任务，则该进程会被移除调度队列，继续执行下一个任务。</li>
<li>如果进程没有在时间片内完成，调度器会将其放回队列末尾，等待下次调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易实现，适用于多任务操作系统。</li>
<li>每个进程都可以得到公平的CPU时间。</li>
<li>特别适用于交互式任务，避免某些进程独占CPU时间。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果时间片设置得太小，频繁的上下文切换会增加开销。</li>
<li>不考虑进程的优先级，可能导致重要的进程在轮转时被延迟。</li>
<li>时间片的选择要合适，过大或过小都会影响系统性能。</li>
</ul>
<p><strong>应用场景</strong>：<br>适用于一般的桌面操作系统和基于时间共享的系统，如Linux和Windows中的用户进程调度。</p>
<h3 id="优先级调度（Priority-Scheduling）"><a href="#优先级调度（Priority-Scheduling）" class="headerlink" title="优先级调度（Priority Scheduling）"></a><strong>优先级调度（Priority Scheduling）</strong></h3><p><strong>概述</strong>：<br>优先级调度是一种基于优先级的调度算法。每个进程都被分配一个优先级值，调度器总是选择优先级最高的进程来执行。高优先级进程会优先于低优先级进程执行，直到它完成或者被阻塞为止。优先级可以是静态的（在进程创建时确定），也可以是动态的（在运行过程中根据进程的行为或外部因素调整）。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程有一个优先级，优先级可以由系统静态设定，或由用户和操作系统动态调整。</li>
<li>调度器选择队列中优先级最高的进程执行，如果多个进程优先级相同，则采用其他算法（如时间片轮转）来调度。</li>
<li>优先级调度可以是抢占式的，即当一个高优先级进程到达时，会抢占正在运行的低优先级进程；也可以是非抢占式的，即进程执行完一个时间片后才会进行调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可以确保高优先级的进程能及时得到执行，适合有不同重要性的任务。</li>
<li>对于实时任务或需要快速响应的进程非常有用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>饥饿问题（Starvation）</strong>：低优先级的进程可能长时间得不到执行，特别是在高优先级进程一直占用CPU时。</li>
<li>不适用于所有任务，因为它忽视了进程的执行时间和公平性。</li>
<li>动态优先级调整可能增加系统的复杂性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于实时操作系统或任务需要严格响应时间的系统。</li>
<li>比如嵌入式系统中的任务调度和硬实时系统。</li>
</ul>
<h3 id="完全公平调度（CFS，Completely-Fair-Scheduling）"><a href="#完全公平调度（CFS，Completely-Fair-Scheduling）" class="headerlink" title="完全公平调度（CFS，Completely Fair Scheduling）"></a><strong>完全公平调度（CFS，Completely Fair Scheduling）</strong></h3><p><strong>概述</strong>：<br>完全公平调度（CFS）是Linux操作系统默认的调度算法，旨在为每个进程提供一个“公平”的CPU时间。与时间片轮转调度不同，CFS不使用固定的时间片，而是使用进程的“虚拟运行时间”（<code>virtual runtime</code>，简称<code>vruntime</code>）来决定哪个进程应该运行。CFS的目标是让每个进程尽可能公平地获得CPU时间，而不是通过固定的时间片来分配资源。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程都有一个<code>vruntime</code>值，表示该进程消耗的CPU时间。当一个进程运行时，它的<code>vruntime</code>会增加。</li>
<li>CFS通过一个红黑树（Red-Black Tree）来管理可执行的进程，树的根节点是<code>vruntime</code>最小的进程，这意味着它会被优先执行。</li>
<li>进程的<code>vruntime</code>会根据其实际运行时间动态调整，长时间运行的进程会让出CPU，短时间运行的进程会被优先调度。</li>
<li>CFS没有固定的时间片，而是基于进程的<code>vruntime</code>来决定调度顺序，进程越公平，<code>vruntime</code>的增加就越慢，调度时得到的CPU时间就越多。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>公平性</strong>：CFS最大程度地保证了进程之间的公平性，每个进程根据其CPU消耗时间来动态调整调度顺序。</li>
<li><strong>灵活性</strong>：相比时间片轮转调度，CFS具有更高的灵活性，可以动态调整每个进程的CPU时间分配，避免了不必要的频繁上下文切换。</li>
<li><strong>低延迟</strong>：对交互式进程提供较低的调度延迟，因为它总是优先调度<code>vruntime</code>较小的进程。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性较高，调度机制依赖于红黑树的实现，可能会增加系统的开销。</li>
<li>对于一些实时应用来说，CFS可能不能提供足够的响应保证，因为它更注重公平性而非严格的实时性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于需要平衡性能和公平性的多任务操作系统，如Linux。CFS是Linux的默认调度算法，适合各种通用计算任务。</li>
<li>不适用于实时性要求较高的任务。</li>
</ul>
<h4 id="CFS实例"><a href="#CFS实例" class="headerlink" title="CFS实例"></a>CFS实例</h4><p>​	为了更好地说明 <strong>完全公平调度（CFS）</strong> 的工作原理，我们可以通过一个更完善的例子来展示进程如何基于 <code>vruntime</code> 值进行调度，并解释不同优先级的进程如何影响 <code>vruntime</code> 的增长速率。</p>
<p>假设场景：</p>
<ul>
<li>系统中有三个进程：<code>进程 A</code>、<code>进程 B</code> 和 <code>进程 C</code>。</li>
<li>进程 A 是高优先级进程，<code>权重 = 1024</code>。</li>
<li>进程 B 是中等优先级进程，<code>权重 = 512</code>。</li>
<li>进程 C 是低优先级进程，<code>权重 = 256</code>。</li>
</ul>
<p>所有进程的初始 <code>vruntime</code> 为 0。</p>
<p>在此例中，我们假设每个进程的 <strong>执行时间</strong> 都为 5 毫秒。</p>
<p>步骤 1：进程 A 执行</p>
<ul>
<li><p>初始时，<code>进程 A</code> 的 <code>vruntime = 0</code>，<code>进程 B</code> 和 <code>进程 C</code> 的 <code>vruntime = 0</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 A</code> 执行，因为它的 <code>vruntime</code> 最小。</p>
</li>
<li><p>进程 A 执行了 5 毫秒。由于 <code>进程 A</code> 的权重为 1024，它的 <code>vruntime</code> 增加的速率较慢。假设 <code>vruntime</code> 增加的计算公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime 增加量 = 执行时间 × 权重因子 / 权重</span><br></pre></td></tr></table></figure>

<p>假设权重因子为 1，进程 A 的 <code>vruntime</code> 增加量是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_A = 5 × 1 / 1024 ≈ 0.00488</span><br></pre></td></tr></table></figure>

<p>进程 A 执行完后，<code>vruntime_A</code> 的新值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_A = 0 + 0.00488 = 0.00488</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 A</code> 执行完后的 <code>vruntime = 0.00488</code>。</p>
</li>
</ul>
<p>步骤 2：进程 C 执行</p>
<ul>
<li><p>当前时刻，<code>进程 A</code> 的 <code>vruntime = 0.00488</code>，<code>进程 B</code> 的 <code>vruntime = 0</code>，<code>进程 C</code> 的 <code>vruntime = 0</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 C</code> 执行，因为它的 <code>vruntime</code> 最小（与进程 B 相同，选择顺序可能不同，但我们假设先执行 C）。</p>
</li>
<li><p>进程 C 执行了 5 毫秒。由于 <code>进程 C</code> 的权重为 256，它的 <code>vruntime</code> 增加量会比进程 A 大。计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_C = 5 × 1 / 256 ≈ 0.01953</span><br></pre></td></tr></table></figure>

<p>进程 C 执行完后的 <code>vruntime</code> 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_C = 0 + 0.01953 = 0.01953</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 C</code> 执行完后的 <code>vruntime = 0.01953</code>。</p>
</li>
</ul>
<p>步骤 3：进程 B 执行</p>
<ul>
<li><p>当前时刻，<code>进程 A</code> 的 <code>vruntime = 0.00488</code>，<code>进程 B</code> 的 <code>vruntime = 0</code>，<code>进程 C</code> 的 <code>vruntime = 0.01953</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 B</code> 执行，因为它的 <code>vruntime</code> 最小。</p>
</li>
<li><p>进程 B 执行了 5 毫秒。由于 <code>进程 B</code> 的权重为 512，它的 <code>vruntime</code> 增加量比进程 A 小，但比进程 C 大。计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_B = 5 × 1 / 512 ≈ 0.00977</span><br></pre></td></tr></table></figure>

<p>进程 B 执行完后的 <code>vruntime</code> 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_B = 0 + 0.00977 = 0.00977</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 B</code> 执行完后的 <code>vruntime = 0.00977</code>。</p>
</li>
</ul>
<p>步骤 4：再次调度</p>
<p>此时，进程 A、B 和 C 的 <code>vruntime</code> 分别为：</p>
<ul>
<li><code>进程 A</code>：<code>vruntime = 0.00488</code></li>
<li><code>进程 B</code>：<code>vruntime = 0.00977</code></li>
<li><code>进程 C</code>：<code>vruntime = 0.01953</code></li>
</ul>
<p>接下来，CFS 会选择 <strong><code>vruntime</code> 最小的进程</strong> 来执行，这个进程是 <code>进程 A</code>，它的 <code>vruntime</code> 最小。然后调度会继续按照这种方式进行，直到所有进程完成执行。</p>
<p><strong>总结</strong>：</p>
<ol>
<li><p><strong>权重（优先级）决定了 <code>vruntime</code> 的增长速率</strong>：</p>
<ul>
<li>高优先级的进程（权重大）其 <code>vruntime</code> 增长较慢，因此可以更长时间占用 CPU。</li>
<li>低优先级的进程（权小）其 <code>vruntime</code> 增长较快，因此调度时优先级较低。</li>
</ul>
</li>
<li><p><strong>进程调度顺序是基于 <code>vruntime</code> 的</strong>，<code>vruntime</code> 越小的进程越容易被调度执行，CFS 会按照进程的 <code>vruntime</code> 值维护一个红黑树（基于红黑树来管理所有可执行的进程）。</p>
</li>
<li><p><strong>公平性</strong>：CFS 会确保所有进程在理论上能够获得相同的 CPU 时间，通过动态调整 <code>vruntime</code>，使得长期运行的进程逐渐让出 CPU 给其他进程。</p>
</li>
</ol>
<p>这种调度方式与传统的基于时间片的调度算法（如时间片轮转）不同，它根据每个进程的实际执行情况来调整调度策略，确保了调度的公平性。</p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a><strong>进程控制块</strong></h2><p>​	<strong>进程控制块</strong>就是用于保存一个进程信息的结构体，又称之为<strong>PCB</strong>。OS是根据PCB来对并发执行的进程进行控制和管理的。系统在创建一个进程的时候会开辟 一段内存空间存放与此进程相关的PCB数据结构。 PCB是操作系统中最重要的记录型数据结构。PCB中记录了用于描述进程进展情况及控制进程运行所需的全部信息。 </p>
<p>​	PCB是进程存在的唯一标志，在Linux中PCB存放在task_struct结构体中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/src</span><br><span class="line">$ <span class="built_in">sudo</span> apt-get install ctags</span><br><span class="line"><span class="built_in">sudo</span> ctags -R</span><br><span class="line"></span><br><span class="line">查看结构体  vim -t task_struct</span><br></pre></td></tr></table></figure>

<p>​	调度数据 (进程的状态,标记优先级,调度策略等)</p>
<p>​	时间数据: 创建该进程的时间,在用户态的运行时间,在内核态的运行时间.</p>
<p>​	文件数据： 文件描述符表,内存数据,进程标识(进程号)</p>
<hr>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><strong>进程控制</strong></h1><h2 id="进程号"><a href="#进程号" class="headerlink" title="进程号"></a><strong>进程号</strong></h2><p>​	每个进程都由一个进程号来标识，其类型为pid_t，进程号的范围：0～32767。进程号是由操作系统随机给当前进程分配的，不能自己控制。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用了</p>
<p>在ubuntu中查看当前系统中所有的开启的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ajx</span><br></pre></td></tr></table></figure>

<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/2.png"></p>
<p><strong>特殊的进程号：</strong> </p>
<p>在linux系统中进程号由0开始。进程号为0及1的进程由内核创建；</p>
<ul>
<li><p>进程号为0的进程通常是调度进程，常被称为交换进程(swapper)；</p>
</li>
<li><p>进程号为1的进程通常是init进程，init进程是所有进程的祖先。除调度进程外，在linux下面所有的进程都由进程init进程直接或者间接创建。</p>
</li>
</ul>
<p><strong>进程号(PID)</strong> ：标识进程的一个非负整型数。 </p>
<p><strong>父进程号(PPID)</strong> ：任何进程(除init进程)都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号(PPID)。 </p>
<p><strong>进程组号(PGID)</strong> ：进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种 </p>
<p>信号，关联的进程有一个进程组号(PGID) 。 </p>
<p><strong>COMMAND</strong>：当前进程的名字 </p>
<p><strong>Linux操作系统提供了三个获得进程号的函数getpid()、getppid()、getpgid()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man getpid    man getpgid</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t getpid(void);</span><br><span class="line">功能：获取当前进程的进程号</span><br><span class="line">pid_t getppid(void);</span><br><span class="line">功能：获取当前进程的父进程的进程号</span><br><span class="line">pid_t getpgid(pid_t pid);</span><br><span class="line">功能：获取当前进程所在进程组的id</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//获取当前进程的进程号</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, getpid());</span><br><span class="line"> <span class="comment">//获取当前进程的父进程的id</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ppid = %d\n&quot;</span>, getppid());</span><br><span class="line"> <span class="comment">//获取当前进程所在组的id</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pgid = %d\n&quot;</span>, getpgid(getpid()));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/3.png"></p>
<h2 id="进程的创建fork函数"><a href="#进程的创建fork函数" class="headerlink" title="进程的创建fork函数"></a>进程的创建fork函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能: 在已有的进程基础上创建一个子进程.</span><br><span class="line">参数无</span><br><span class="line">返回值:</span><br><span class="line">  成功:</span><br><span class="line">   	&gt;<span class="number">0</span> 子进程的进程号,标识父进程的代码区</span><br><span class="line">  	 <span class="number">0</span>  子进程的代码区</span><br><span class="line">  失败:</span><br><span class="line">    <span class="number">-1</span>  返回给父进程,子进程不会创建.</span><br></pre></td></tr></table></figure>

<p>使用fork函数得到的子进程是父进程的一个复制品,它从父进程处继承了整个进程的地址空间。</p>
<p>地址空间：包括进程上下文,进程堆栈,打开的文件描述,信号控制设定,进程优先级,进程组号等。子进程所独有的只有它的进程号,计时器,因此,使用fork函数的代价是很大的.</p>
<p>  <strong>fork函数执行完毕后父子进程的空间示意图：</strong></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/4.png"></p>
<h2 id="程序区域划分"><a href="#程序区域划分" class="headerlink" title="程序区域划分"></a>程序区域划分</h2><p>在程序运行时，内存被分为不同的区域，用来存储代码、数据、堆栈等内容。</p>
<ol>
<li><strong>栈区</strong>（Stack Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 栈区用于存储函数调用过程中自动分配的局部变量、函数参数和返回地址等数据。栈区的内存由系统自动分配和释放，遵循后进先出的原则。</li>
<li><strong>特点</strong>:<ul>
<li><strong>自动管理</strong>: 当函数被调用时，局部变量在栈上分配；函数返回时，栈上的局部变量会自动销毁。</li>
<li><strong>空间有限</strong>: 栈的大小通常是有限的，过大的递归调用或分配过多的局部变量可能导致栈溢出（Stack Overflow）。</li>
<li><strong>高速存取</strong>: 栈内存的分配和释放速度非常快。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>堆区</strong>（Heap Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 堆区用于动态分配内存，通常由程序员手动分配和释放（例如通过 <code>new</code> 和 <code>delete</code> 等函数在 C&#x2F;C++ 中进行操作）。堆的内存可以在程序运行时动态增长或缩减。</li>
<li><strong>特点</strong>:<ul>
<li><strong>手动管理</strong>: 程序员负责内存的分配和释放，使用不当可能导致内存泄漏或碎片化。</li>
<li><strong>较大空间</strong>: 与栈相比，堆的内存空间通常更大，可以用于分配大块的内存。</li>
<li><strong>灵活性高</strong>: 适合不确定大小的数据结构，例如链表、树等。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>BSS</strong>区（BSS Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: BSS 区（Block Started by Symbol）用于存放未初始化的全局变量和静态变量。该区域在程序加载时由操作系统初始化为零。</li>
<li><strong>特点</strong>:<ul>
<li><strong>零初始化</strong>: 所有在 BSS 区的变量在程序运行前都会被自动清零。</li>
<li><strong>只存储未初始化数据</strong>: 如果全局或静态变量在定义时没有显式初始化，它们就会被放在 BSS 区。</li>
<li><strong>节省空间</strong>: 未初始化的变量并不占用可执行文件中的空间，它们只是在程序运行时才占用内存。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>数据区</strong>（Data Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 数据区用于存放已初始化的全局变量和静态变量。这些变量的初始值会随程序一起加载进内存，并在整个程序的生命周期内存在。</li>
<li><strong>特点</strong>:<ul>
<li><strong>全局存储</strong>: 包含了所有程序中已初始化的全局变量和静态变量。</li>
<li><strong>可读写</strong>: 数据区中的变量在程序运行期间是可读写的，不会随函数的调用和结束而消失。</li>
<li><strong>持久性</strong>: 这些变量在整个程序运行期间都存在，并且可以跨函数访问。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>代码区</strong>（Text Segment）</li>
</ol>
<ul>
<li><strong>定义</strong>: 代码区（又称文本区）存储程序的机器指令，即程序的代码部分。它是只读的，以防止程序在运行时意外修改自己的指令。</li>
<li><strong>特点</strong>:<ul>
<li><strong>只读</strong>: 通常代码区是不可写的，防止修改代码。</li>
<li><strong>共享性</strong>: 代码区可以在多线程或多进程之间共享，比如多个进程可以运行同一个可执行文件的不同实例，它们可以共享代码区。</li>
<li><strong>不可变性</strong>: 在程序运行时，代码区的数据（指令）不会改变。</li>
</ul>
</li>
</ul>
<p><strong>内存布局总结</strong></p>
<p>通常程序的内存布局可以按以下顺序从高地址到低地址分布：</p>
<ol>
<li><strong>栈区（Stack）</strong>: 由高地址向低地址增长。</li>
<li><strong>堆区（Heap）</strong>: 由低地址向高地址增长，动态分配的内存位于这里。</li>
<li><strong>BSS 区（BSS）</strong>: 存储未初始化的全局变量和静态变量，初始值为 0。</li>
<li><strong>数据区（Data）</strong>: 存储已初始化的全局变量和静态变量。</li>
<li><strong>代码区（Text）</strong>: 存储程序的代码，通常是只读的。</li>
</ol>
<h2 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h2><p>1.创建子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行一次fork，就会在原有的进程基础上创建一个新的子进程</span></span><br><span class="line"><span class="comment">//而且如果fork之后不区分父子进程的代码区，则后面所有的代码都会执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//fflush(stdout);</span></span><br><span class="line">	fork();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">   <span class="comment">// fflush(NULL);</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建区分主进程与子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork后区分父子进程</span></span><br><span class="line"><span class="comment">//使用fork()创建子进程标准代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>,getpid());    <span class="comment">//一定是父进程打印的</span></span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork创建进程错误!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:子进程正在工作...\n&quot;</span>,getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:父进程正在工作...\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%d]End!\n&quot;</span>,getpid());</span><br><span class="line">   <span class="comment">//  getchar();</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证系统进程调度方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     pid=fork();</span><br><span class="line">     <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]子进程正在运行中....\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程i=====%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]父进程正在运行中....\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程k=====%d\n&quot;</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.父进程拥有独立的地址空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父子进程拥有独立的地址空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> z = <span class="number">10</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程的代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程....\n&quot;</span>);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        z++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>, x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程的代码区</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>, x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/7.png"></p>
<p>4.子进程继承父进程的空间,</p>
<p>   子进程会继承父进程的一些公有的区域,比如磁盘空间，内核空间。文件描述符的偏移量保存在内核空间中,所以父进程改变偏移量,则子进程获取的偏移量是改变之后的.所以子进程继承父进程的空间.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子进程会继承父进程的一些公有的区域。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd=open(<span class="string">&quot;myfile.txt&quot;</span>,O_RDONLY))==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open file fail...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork fail....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid &gt;<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程....\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">32</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(read(fd,buffer,<span class="number">20</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read file fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buffer=[%s]\n&quot;</span>,buffer);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;子进程....\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">32</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(read(fd,buffer,<span class="number">20</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;read file fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buffer=[%s]\n&quot;</span>,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果图:</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/8.png"></p>
<h2 id="进程sleep-睡眠状态"><a href="#进程sleep-睡眠状态" class="headerlink" title="进程sleep 睡眠状态"></a>进程sleep 睡眠状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能：进程在一定的时间内没有任何动作，称为进程的挂起（进程处于等待态）</span><br><span class="line">参数：</span><br><span class="line">seconds：指定要挂起的秒数</span><br><span class="line">返回值：</span><br><span class="line">若进程挂起到second指定的时间则返回<span class="number">0</span>，若有信号中断则返回剩余秒数</span><br><span class="line">注意：</span><br><span class="line">进程挂起指定的秒数后程序并不会立即执行，系统只是将此进程切换到就绪态</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        <span class="comment">//当运行到sleep函数后，程序会在此位置等待设定的秒数，当秒数到达后，代码会接着执行</span></span><br><span class="line">        <span class="comment">//sleep运行时进程为等待态，时间到达后会先切换到就绪态，如果代码继续运行，再切换到运行态</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程的等待wait函数"><a href="#进程的等待wait函数" class="headerlink" title="进程的等待wait函数"></a><strong>进程的等待wait函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。调用wait函数的进程会挂起，直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒。若调用进程没有子进程或它的子进程已经结束，该函数立即返回。</span><br><span class="line">    </span><br><span class="line">参数：status：函数返回时，参数status中包含子进程退出时的状态信息。子进程的退出信息在一个<span class="type">int</span>中包含了多个字段，用宏定义可以取出其中的每个字段。子进程可以通过<span class="built_in">exit</span>或者_exit函数发送退出状态。</span><br><span class="line">    </span><br><span class="line">返回值：</span><br><span class="line">	成功：子进程的进程号。</span><br><span class="line">	失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> <code>WIFEXITED(status)</code>：取出子进程的退出信息。</p>
<p>​	如果子进程是正常终止的，取出的字段值非零。 </p>
<p><code>WEXITSTATUS(status)</code>：返回子进程的退出状态。</p>
<p>​	返回子进程的退出状态，退出状态保存在status变量的8~16位。 在用此宏前应先用宏WIFEXITED判断子进程是否正常退出，正常退出才可以使用此宏。 </p>
<p><strong>注意</strong>： 此status是wait的参数指向的整型变量。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	pid=fork();</span><br><span class="line">	if(pid&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;进程创建失败&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">	if(pid == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		int i = 0;</span><br><span class="line">		for(i=0;i&lt;3;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;子进程\n&quot;);</span><br><span class="line">			sleep(1);</span><br><span class="line">		&#125;</span><br><span class="line">		//使用exit退出当前进程并设置退出状态</span><br><span class="line">		exit(3);</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		//使用wait在父进程中阻塞等待子进程的退出</span><br><span class="line">		//不接收子进程的退出状态</span><br><span class="line">		//wait(NULL);</span><br><span class="line">		//接收子进程的退出状态，子进程中必须使用exit或者_exit函数退出进程是发送退出状态</span><br><span class="line">		int status = 0;</span><br><span class="line">		wait(&amp;status);</span><br><span class="line">		if(WIFEXITED(status) != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;子进程返回状态: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;父进程\n&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status,<span class="type">int</span> options)</span></span><br><span class="line">功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">pid：指定的进程或者进程组</span><br><span class="line">	pid&gt;0：等待进程ID等于pid的子进程。</span><br><span class="line">	pid=<span class="number">0</span>：等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会等待它。</span><br><span class="line">	pid=‐<span class="number">1</span>：等待任一子进程，此时waitpid和wait作用一样。</span><br><span class="line">	pid&lt;‐<span class="number">1</span>：等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值</span><br><span class="line">status：保存子进程退出时的状态信息</span><br><span class="line">options：选项</span><br><span class="line">	<span class="number">0</span>：同wait，阻塞父进程，等待子进程退出。</span><br><span class="line">	WNOHANG：没有任何已经结束的子进程，则立即返回。非阻塞形式</span><br><span class="line">	WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（跟踪调试，很少用到）</span><br><span class="line">返回值：</span><br><span class="line">	成功：返回状态改变了的子进程的进程号；如果设置了选项WNOHANG并且pid指定的进程存在则返回<span class="number">0</span>。</span><br><span class="line">	失败：返回‐<span class="number">1</span>。当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</span><br><span class="line">wait(status) &lt;==&gt; waitpid(‐<span class="number">1</span>, status, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	</span><br><span class="line">	pid=fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;子进程\n&quot;</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;		</span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;父进程\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>僵尸进程</strong> : 进程已经结束,但进程的占用的资源未被回收,这样的进程称为僵尸进程.子进程已经运行结束,父进程未调用<code>wait</code>或<code>waitpid</code>函数回收子进程的资源使子进程变为僵尸进程的原因.</p>
</li>
<li><p><strong>孤儿进程</strong>:父进程运行结束,但子进程未运行结束的子进程.</p>
</li>
<li><p><strong>守护进程</strong>:守护进程是个特殊的孤儿进程,这种进程脱离终端,在后台运行.</p>
</li>
</ul>
<h2 id="进程的终止exit-exit"><a href="#进程的终止exit-exit" class="headerlink" title="进程的终止exit&#x2F;_exit"></a><strong>进程的终止exit&#x2F;_exit</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">	一般失败退出设置为非<span class="number">0</span>;成功退出设置为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>_exit函数</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">一般失败退出设置为非<span class="number">0</span>,成功退出设置为<span class="number">0</span></span><br><span class="line"><span class="number">8</span> 返回值：</span><br><span class="line"><span class="number">9</span> 无</span><br></pre></td></tr></table></figure>

<p>exit和_exit函数的区别： </p>
<p>exit为库函数，而_exit为系统调用 </p>
<p>exit会刷新缓冲区，但是_exit不会刷新缓冲区 </p>
<p>一般会使用exit  </p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/9.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BBB\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CCC\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;AAA\n&quot;</span>);</span><br><span class="line">   fun();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;DDD\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>return 除了返回值以外,在主函数中可以退出进程,但是在子函数中使用只能退出当前函数.</p>
<p>exit(0) 可以退出一个进程,且可以刷新缓冲区.</p>
<p>_exit(0) 可以退出一个进程,但是不会刷新缓冲区.</p>
<h2 id="进程退出清理atexit"><a href="#进程退出清理atexit" class="headerlink" title="进程退出清理atexit"></a><strong>进程退出清理</strong>atexit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br><span class="line">功能: 注册进程正常结束前调用的函数,进程退出执行注册函数.</span><br><span class="line">参数: function: 进程结束前,调用函数的入口地址.</span><br><span class="line">    一个进程中可以多次调用atexit函数注册清理函数.</span><br><span class="line">    正常结束前调用函数的顺序和注册时的顺序相反.</span><br><span class="line">返回值:</span><br><span class="line">   成功: <span class="number">0</span></span><br><span class="line">   失败: 非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clear fun1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clear fun2...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;clear fun3...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//atexit函数在进程结束时,才会去执行参数对应的回调函数.</span></span><br><span class="line">    atexit(fun1);</span><br><span class="line">    atexit(fun2);</span><br><span class="line">    atexit(fun3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****************\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while(1)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程的创建–vfork函数"><a href="#进程的创建–vfork函数" class="headerlink" title="进程的创建–vfork函数"></a><strong>进程的创建–vfork函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能:vfork函数和fork函数一样都是在已有的进程中创建一个新的进程,但是它们创建的子进程是有区别的.vfork保证子进程先运行,在它调用exec,<span class="built_in">exit</span>或者正常结束之后,父进程才可能被调度运行.</span><br><span class="line">参数: 无</span><br><span class="line">返回值:</span><br><span class="line">  成功:  子进程中返回<span class="number">0</span>, 父进程中返回子进程ID</span><br><span class="line">  失败:  <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     <span class="comment">//使用vfork函数创建子进程</span></span><br><span class="line">     pid=vfork();</span><br><span class="line">     <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;子进程创建失败...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程在运行中...\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//父进程代码区</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程运行中....\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子进程和父进程共享同一块空间-vfork创建"><a href="#子进程和父进程共享同一块空间-vfork创建" class="headerlink" title="子进程和父进程共享同一块空间(&#x3D;vfork创建)"></a><strong>子进程和父进程共享同一块空间(&#x3D;vfork创建)</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fork创建</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> y=<span class="number">10</span>;</span><br><span class="line">     <span class="type">int</span> z=<span class="number">10</span>;</span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     pid=fork();</span><br><span class="line">     <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;创建进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程的代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程....\n&quot;</span>);</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">        z++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>,x,y,z);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//子进程的代码区</span></span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;子进程...\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d, z=%d\n&quot;</span>,x,y,z);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vfork创建</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> y=<span class="number">200</span>;</span><br><span class="line">     <span class="type">int</span> z=<span class="number">300</span>;</span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     <span class="comment">//子进程会复制父进程fork之前的所有内容,但是fork之后,父子进程完全独立,所以不管双方怎么改变(堆区,栈区,数据区),都不会影响对方</span></span><br><span class="line">     pid=vfork();</span><br><span class="line">     <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;创建进程失败!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程的代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程正在运行中...\n&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x==%d,y==%d,z==%d\n&quot;</span>,x,y,z);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//子进程的代码区</span></span><br><span class="line">       </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;子进程正在运行中...\n&quot;</span>);</span><br><span class="line">           x++;</span><br><span class="line">           y++;</span><br><span class="line">           z++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x==%d,y==%d,z==%d\n&quot;</span>,x,y,z);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="vfork-与-fork的区别"><a href="#vfork-与-fork的区别" class="headerlink" title="vfork 与 fork的区别"></a>vfork 与 fork的区别</h2><p><code>vfork()</code> 和 <code>fork()</code> 都是用于创建子进程的系统调用，但它们之间有一些重要的区别，特别是在父进程和子进程之间共享内存空间的情况上。以下是两者的区别：</p>
<ol>
<li><p><strong>内存空间</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li><code>fork()</code> 创建一个新的子进程，子进程拥有父进程的<strong>完整拷贝</strong>，包括内存地址空间、文件描述符等。</li>
<li>在现代操作系统中，<code>fork()</code> 通常使用 <strong>写时拷贝</strong> (copy-on-write) 机制，即只有当父子进程中的某一方修改数据时，操作系统才会为子进程创建该数据的副本。这减少了不必要的内存开销。</li>
<li>因此，子进程最初看似共享父进程的内存空间，但实际上两者是独立的，只有在数据发生变化时才分开。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li><code>vfork()</code> 主要用于优化性能。与 <code>fork()</code> 不同的是，<code>vfork()</code> 不会立即复制父进程的内存空间。子进程会<strong>直接共享父进程的地址空间</strong>，直到子进程调用 <code>exec()</code> 或 <code>exit()</code>。</li>
<li>在 <code>vfork()</code> 之后、调用 <code>exec()</code> 或 <code>exit()</code> 之前，父进程会被阻塞，等待子进程完成。因为子进程和父进程共享同一个地址空间，子进程对内存的修改会直接影响父进程。</li>
<li>这种行为带来了一些风险：如果子进程在调用 <code>exec()</code> 或 <code>exit()</code> 之前修改了内存内容，父进程的数据可能会被破坏。因此，使用 <code>vfork()</code> 时要小心，避免在子进程中执行不安全的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li>由于 <code>fork()</code> 创建了父进程内存空间的副本，尽管使用了写时拷贝技术，其开销还是比 <code>vfork()</code> 大一些，尤其是在内存较大的进程中。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li><code>vfork()</code> 的性能更好，因为它不需要复制父进程的内存空间。子进程直接使用父进程的内存，因此减少了内存和CPU的开销。</li>
<li>这种方式在创建短时间内就要调用 <code>exec()</code> 的子进程时非常高效。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>执行顺序</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li>在 <code>fork()</code> 之后，父进程和子进程是独立执行的，谁先执行取决于调度器。父进程并不会等待子进程。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li>在 <code>vfork()</code> 之后，父进程会被阻塞，直到子进程调用 <code>exec()</code> 或 <code>exit()</code> 完成。这样确保了子进程优先执行，而父进程不会在子进程完成之前继续运行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><p><strong><code>fork()</code>：</strong></p>
<ul>
<li>适合需要在父子进程中保持独立内存空间的情况，尤其是当子进程需要继续运行而不立即执行新程序时。</li>
</ul>
</li>
<li><p><strong><code>vfork()</code>：</strong></p>
<ul>
<li>适合性能敏感的场景，特别是在创建子进程后马上调用 <code>exec()</code> 执行新程序的场合。避免了不必要的内存拷贝。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>fork()</code>：子进程和父进程在创建时拥有独立的内存空间，虽然初始状态下看起来共享，但修改时内存会被复制，属于“写时拷贝”。</li>
<li><code>vfork()</code>：子进程在调用 <code>exec()</code> 或 <code>exit()</code> 之前，和父进程共享同一个内存空间，使用时要小心，防止子进程修改父进程的数据。</li>
</ul>
<h2 id="进程的替换exec"><a href="#进程的替换exec" class="headerlink" title="进程的替换exec"></a><strong>进程的替换exec</strong></h2><p>exec函数族，是由六个exec函数组成的。 </p>
<ul>
<li><p>exec函数族提供了六种在进程中启动另一个程序的方法。 </p>
</li>
<li><p>exec函数族可以根据指定的文件名或目录名找到可执行文件。 </p>
</li>
<li><p>调用exec函数的进程并不创建新的进程，故调用exec前后，进程的进程号并不会改变，其执行的程序完全由新的程序替换，而新程序则从其main函数开始执行。</p>
</li>
</ul>
<p>exec函数族取代调用进程的数据段、代码段和堆栈段</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/10.png"></p>
<p>一个进程调用exec后，除了进程ID，进程还保留了下列特征不变： </p>
<p>​	父进程号、进程组号 、控制终端、根目录、当前工作目录、进程信号屏蔽集、未处理信号</p>
<p><strong>exec函数族</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL*/</span>, <span class="type">char</span> * <span class="type">const</span> envp[] )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>：在一个进程里面执行另一个程序，主要用于执行命令<br><strong>参数</strong>：</p>
<ul>
<li><p>path：命令或者程序的路径</p>
</li>
<li><p>l：如果是带l的函数，对应的命令或者程序是通过每一个参数进行传递的，最后一个为NULL表示结束。例如：<code>&quot;ls&quot;, &quot;‐l&quot;, NULL</code></p>
</li>
<li><p>v:如果是带v的函数，对应的命令或者程序是通过一个指针数组来传递的，指针数组的最后一个元素为NULL标识结束。例如：<code>char *str[] = &#123;&quot;ls&quot;, &quot;‐l&quot;, NULL&#125;;</code></p>
</li>
<li><p>p：如果是不带p的函数，第一个参数必须传当前命令或者程序的绝对路径，如果是带p的函数，第一个参数既可以是绝对路径，也可以是相对路径</p>
</li>
<li><p>e:  允许你传递一个自定义的环境变量数组（<code>envp[]</code>），因此可以为新程序指定不同于当前进程的环境变量。自定义的环境变量数组 <code>envp[]</code> 使得你可以在调用 <code>execve()</code> 或 <code>execvpe()</code> 时，为新进程传递特定的环境变量。通过这种方式，你能够控制新程序的运行环境，与当前进程的环境隔离开来。这在需要运行特定环境设置的子进程时非常有用。</p>
</li>
</ul>
<p><strong>返回值</strong>：成功：1；失败：‐1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">例子<span class="number">1.</span></span><br><span class="line"> <span class="comment">//调用exec函数族中的函数，执行其他命令或者程序</span></span><br><span class="line"> <span class="comment">//查看命令的路径：whereis 命令或者which 命令</span></span><br><span class="line"> <span class="comment">//exec函数族可以调用shell命令</span></span><br><span class="line"> <span class="comment">//不带p的函数，命令的路径一定要用绝对路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程在运行中\n&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程运行结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程运行中\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execl&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">第二种方式:</span><br><span class="line"> <span class="comment">//带p的函数，第一个参数既可以是相对路径，也可以是绝对路径</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execlp&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">第三种方式:</span><br><span class="line"><span class="comment">//带v的函数需要使用指针数组来传递</span></span><br><span class="line">    <span class="type">char</span> *str[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(execv(<span class="string">&quot;/bin/ls&quot;</span>, str) == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         perror(<span class="string">&quot;fail to execv&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> 第四种方式:</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//***************exec函数族调用可执行文件******************     </span></span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">&quot;./hello&quot;</span>, <span class="string">&quot;./hello&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execlp&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">第五种方式:</span><br><span class="line">   <span class="comment">//***************exec函数族调用shell脚本******************       </span></span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">&quot;./myshell.sh&quot;</span>, <span class="string">&quot;./myshell.sh&quot;</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to execl&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">2</span></span><br><span class="line">print_env.c:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;USER: %s\n&quot;</span>, getenv(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH: %s\n&quot;</span>, getenv(<span class="string">&quot;PATH&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execve.c:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;./print_env&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *envp[] = &#123;</span><br><span class="line">        <span class="string">&quot;USER=custom_user&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PATH=/custom/path&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">&quot;./print_env&quot;</span>, args, envp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 execve 执行成功，下面的代码不会被执行</span></span><br><span class="line">    perror(<span class="string">&quot;execve failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">通过gcc print_env.c -o print_env 创建可执行文件后，运行execve.c</span><br></pre></td></tr></table></figure>

<h2 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a><strong>system函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br><span class="line">功能：执行一个shell命令（shell命令、可执行文件、shell脚本）</span><br><span class="line">system会调用fork函数产生子进程，</span><br><span class="line">子进程调用exec启动/bin/sh ‐c <span class="built_in">string</span></span><br><span class="line">来执行参数<span class="built_in">string</span>字符串所代表的命令，</span><br><span class="line">此命令执行完后返回原调用进程</span><br><span class="line">参数：</span><br><span class="line">	command：要执行的命令的字符串</span><br><span class="line">返回值：</span><br><span class="line">	如果command为<span class="literal">NULL</span>，则system()函数返回非<span class="number">0</span>，一般为<span class="number">1</span>。</span><br><span class="line">	如果system()在调用/bin/sh时失败则返回<span class="number">127</span>，其它失败原因返回‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //使用system执行shell命令</span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    system(&quot;ls -l&quot;);</span><br><span class="line">    system(&quot;./myhello&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="system-与-exec-的区别与相同点"><a href="#system-与-exec-的区别与相同点" class="headerlink" title="system 与 exec 的区别与相同点"></a>system 与 exec 的区别与相同点</h3><p><code>system()</code> 和 <code>exec()</code> 系列函数都是用于在 C 程序中执行外部命令或程序的函数，但它们在行为、功能和用途上有显著的区别。以下是两者的区别和相同点：</p>
<p><strong>相同点</strong></p>
<ol>
<li><p><strong>执行外部命令或程序</strong>：</p>
<ul>
<li>两者都可以用于执行外部的命令或程序。例如，调用 shell 命令、运行可执行文件等。</li>
</ul>
</li>
<li><p><strong>基于操作系统的函数</strong>：</p>
<ul>
<li><code>system()</code> 和 <code>exec()</code> 都是操作系统提供的函数，它们的行为依赖于操作系统的实现。</li>
</ul>
</li>
</ol>
<p><strong>不同点</strong></p>
<ol>
<li><p><strong>执行方式</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li><code>system()</code> 会调用一个 shell 来执行指定的命令。它首先创建一个新的子进程，然后在该子进程中执行 shell 命令。执行完命令后，子进程会终止，父进程会等待子进程结束并返回其退出状态。</li>
<li><code>system()</code> 函数会阻塞父进程的执行，直到命令执行完毕。<ul>
<li><code>system()</code> 返回值是子进程的退出状态，如果命令执行失败，返回值可能是 -1。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li><p><code>exec()</code> 系列函数不调用 shell，而是直接用指定的程序替换当前进程的映像。这意味着调用 <code>exec()</code> 后，当前进程的代码和数据会被新程序的代码和数据替代，不再返回到调用 <code>exec()</code> 的代码中。</p>
</li>
<li><p><code>exec()</code> 不会创建新进程，而是在当前进程中直接加载并执行新程序。</p>
</li>
<li><p><code>exec()</code> 系列有多个变体（如 <code>execl()</code>, <code>execv()</code>, <code>execvp()</code> 等），用于根据不同的需求传递参数。无论使用哪个变体，<code>exec()</code> 都不会返回，除非发生错误。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程关系</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li><code>system()</code> 创建一个新的子进程执行命令，而父进程保持不变。子进程完成后，父进程会继续执行原来的代码。</li>
<li>父进程和子进程之间没有共享数据，子进程完成任务后就会退出。</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li><code>exec()</code> 不创建子进程，而是用新程序替换当前进程。调用 <code>exec()</code> 的进程会直接被新程序替代，不再返回。由于没有创建新进程，因此调用 <code>exec()</code> 后，当前进程的进程 ID 不变，但执行的代码已经是新程序的内容。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li>适合简单地调用外部命令或脚本，且希望父进程在子进程执行完毕后继续执行的场景。</li>
<li>例如：在程序中调用 shell 脚本或系统命令，并等待其完成后继续执行后续代码。</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li>适合用当前进程执行另一个程序的场景，特别是当你不再需要执行当前进程的代码时。</li>
<li>常见用法是在 <code>fork()</code> 之后调用 <code>exec()</code>，子进程调用 <code>exec()</code> 来执行新程序，而父进程继续执行其他任务。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回行为</strong></p>
<ul>
<li><p><code>system()</code>：</p>
<ul>
<li><code>system()</code> 执行完命令后会返回，返回值是命令的退出状态，因此父进程可以检查命令的执行结果。</li>
</ul>
</li>
<li><p><code>exec()</code>：</p>
<ul>
<li><code>exec()</code> 函数不会返回，除非发生错误。如果执行成功，当前进程被新程序替换；如果失败，<code>exec()</code> 会返回 -1，并设置 <code>errno</code> 以指示错误原因。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><code>system()</code>：在子进程中执行外部命令，父进程等待子进程完成并返回退出状态。适合简单的命令执行场景。</li>
<li><code>exec()</code>：用新程序替换当前进程，不会返回。适合需要完全替换当前进程执行另一个程序的场景。</li>
</ul>
<p>如果你的任务是执行一个命令并继续当前程序的运行，使用 <code>system()</code> 更方便；如果你需要完全替换当前进程为另一个程序，使用 <code>exec()</code> 是更好的选择。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="进程间通信概述"><a href="#进程间通信概述" class="headerlink" title="进程间通信概述"></a><strong>进程间通信概述</strong></h2><p>​	进程间通信<code>IPC:Inter Processes Communication</code>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程)之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。 </p>
<p>​	进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信。 </p>
<p>进程间通信功能： </p>
<ul>
<li><p>数据传输：一个进程需要将它的数据发送给另一个进程。 </p>
</li>
<li><p>资源共享：多个进程之间共享同样的资源。 </p>
</li>
<li><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。 </p>
</li>
<li><p>进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。</p>
</li>
</ul>
<p>Linux操作系统支持的主要<code>IPC</code></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/11.png"></p>
<p><strong>进程间通信的实质：</strong> </p>
<p>​	系统只要创建一个进程，就会给当前进程分配4G的虚拟内存（32位操作系统），虚拟内存不是常说的内存条的空间，内存条的空间称之为物理内存，虚拟内存和物理内存之间存在映射关系。4G的虚拟内存分为3G的用户空间（0 ~ 3G）和1G（3 ~ 4G）的内核空间，用户空间是进程所私有的，每一个进程的用户空间只能自己访问和使用，我们之前说的栈区、堆区、数据区、代码区等都是用户空间的区域，内核空间是所有进程所公有的，也就意味着绝大多数进程间通信方式，本质就是对内核空间的操作。</p>
<p><strong>特殊的进程间通信方式：</strong> </p>
<ul>
<li><p><code>socket</code>通信可以实现不同主机的进程间通信，其他六个只能在一台主机的多个进程间通信 </p>
</li>
<li><p>信号通信是唯一的一种异步通信机制 </p>
</li>
<li><p>共享内存是所有进程间通信方式中效率最高的，它是直接对物理内存进行操作</p>
</li>
</ul>
<h2 id="信号的概述"><a href="#信号的概述" class="headerlink" title="信号的概述"></a><strong>信号的概述</strong></h2><h3 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a><strong>信号的概念</strong></h3><p>​	信号是软件中断，它是在软件层次上对中断机制的一种模拟。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。信号是一种异步通信方式。进程不必等待信号的到达，进程也不知道信号什么时候到达。信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。 </p>
<p>​	每个信号的名字都以字符SIG开头。每个信号和一个数字编码相对应，在头文件<code>signum.h</code>中，这些信号都被定义为正整数。 </p>
<p>​	信号名定义路径：<code>/usr/include/x86_64-linux-gnu/bits /signum.h </code></p>
<p>​	在Linux下，要想查看这些信号和编码的对应关系，可使用命令：<code>kill ­-l</code></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/12.png"></p>
<p>​	信号是由当前系统已经定义好的一些标识，每一个标识都会在特定的场合使用并且都会对进程有一定的影响，当信号产生时，会让当前信号做出相应的操作这些信号。都是已经定义好的，我们<strong>不能自定义创造</strong>，直接使用这些就可以。</p>
<h3 id="产生信号的方式"><a href="#产生信号的方式" class="headerlink" title="产生信号的方式"></a><strong>产生信号的方式</strong></h3><ol>
<li>当用户按某些终端键时，将产生信号：</li>
</ol>
<p>&#9;终端上按<code>Ctrl+c</code>组合键通常产生中断信号<code>SIGINT</code>；终端上按<code>Ctrl+\</code>键通常产生中断信号<code>SIGQUIT</code>；终端上按<code>Ctrl+z</code>键通常产生中断信号<code>SIGTSTP</code>。 </p>
<ol start="2">
<li>硬件异常将产生信号：</li>
</ol>
<p>&#9;除数为0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核,然后内核产生适当的信号发送给相应的进程。 </p>
<ol start="3">
<li>软件异常将产生信号：</li>
</ol>
<p>&#9;当检测到某种软件条件已发生，并将其通知有关进程时，产生信号。 </p>
<ol start="4">
<li>调用kill函数将发送信号：</li>
</ol>
<p>&#9;接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。 </p>
<ol start="5">
<li>运行kill命令将发送信号：</li>
</ol>
<p>&#9;此程序实际上是使用kill函数来发送信号。也常用此命令终止一个失控的后台进程。 </p>
<h3 id="信号的默认（缺省）处理方式"><a href="#信号的默认（缺省）处理方式" class="headerlink" title="信号的默认（缺省）处理方式"></a><strong>信号的默认（缺省）处理方式</strong></h3><p>当进程中产生了一个信号，就会让当前进程做出一定的反应，默认处理进程的方式如下 </p>
<ol>
<li><p>终止进程：当信号产生后，当前进程就会立即结束 </p>
</li>
<li><p>缺省处理：当信号产生后，当前进程不做任何处理 </p>
</li>
<li><p>停止进程：当信号产生后，使得当前进程停止 </p>
</li>
<li><p>让停止的进程恢复运行：当信号产生后，停止的进程会恢复执行（后台进程）</p>
</li>
</ol>
<h3 id="进程接收到信号后的处理方式"><a href="#进程接收到信号后的处理方式" class="headerlink" title="进程接收到信号后的处理方式"></a><strong>进程接收到信号后的处理方式</strong></h3><p><strong>1、执行系统默认动作</strong> </p>
<p>对大多数信号来说，系统默认动作是用来终止该进程。 </p>
<p><strong>2、忽略此信号</strong> </p>
<p>接收到此信号后没有任何动作。 </p>
<p><strong>3、执行自定义信号处理函数</strong> </p>
<p>用用户定义的信号处理函数处理该信号。</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>性质</th>
<th>默认处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>SIGKILL</td>
<td>9</td>
<td>当产生这个信号后，当前进程会退出，</td>
<td>退出进程</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>19</td>
<td>当产生这个信号后，当前进程会停止，不能被缺省和捕捉</td>
<td>停止进程</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>键盘输入ctrl+c时产生信号</td>
<td>退出进程</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>键盘输入ctrl+\时产生信号</td>
<td>退出进程</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>20</td>
<td>键盘输入ctrl+z时产生信号</td>
<td>停止进程</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>18</td>
<td>当产生当前信号后，当前停止的进程会恢复运行</td>
<td>停止的进程恢复运行</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>当调用alarm函数设置的时间到达时会产生当前信号</td>
<td>退出进程</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>当管道破裂时，会产生当前信号</td>
<td>退出进程</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>当调用abort函数时会产生当前信号</td>
<td>退出进程</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>17</td>
<td>当使用fork创建一个子进程时，如果子进程状态改变（退出），会产生当前信号</td>
<td>缺省</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>10</td>
<td>用户自定义信号，不会自动产生，只能使用kill函数或者命令给指定的进程发送当前信号</td>
<td>缺省</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>12</td>
<td>用户自定义信号，不会自动产生，只能使用kill函数或者命令给指定的进程发送当前信号</td>
<td>缺省</td>
</tr>
</tbody></table>
<h2 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a><strong>kill函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定的进程或者进程组发送信号</span><br><span class="line">参数：</span><br><span class="line">pid：</span><br><span class="line">	pid&gt;<span class="number">0</span>: 将信号传送给进程ID为pid的进程。</span><br><span class="line">	pid=<span class="number">0</span>: 将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">	pid=‐<span class="number">1</span>: 将信号传送给系统内所有的进程，除了init进程</span><br><span class="line">	pid&lt;‐<span class="number">1</span>: 将信号传给指定进程组的所有进程。这个进程组号等于pid的绝对值。</span><br><span class="line">sig：指定的信号</span><br><span class="line">返回值：</span><br><span class="line">	成功：<span class="number">0</span></span><br><span class="line">	失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="comment">//父进程的代码区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;父进程\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//子进程的代码区 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程\n&quot;</span>);</span><br><span class="line">        <span class="comment">//子进程在3秒之后，让父进程退出</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//使用kill给父进程发送信号，然后父进程接收到信号后直接退出就可以了</span></span><br><span class="line">        kill(getppid(), SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a><strong>alarm函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line">功能: 定时器,闹钟,当设定的时间到时,会产生SIGALRM信号</span><br><span class="line">参数: second设定的秒数</span><br><span class="line">返回值  </span><br><span class="line">  如果alarm函数之前没有alarm设置,则返回<span class="number">0</span></span><br><span class="line">  如果有,则返回上一个alarm剩余的时间(覆盖上一个定时器).</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> second;</span><br><span class="line">    second=alarm(<span class="number">5</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    second=alarm(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;second= %d\n&quot;</span>,second);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AAAAAAA\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise 函数"></a><strong>raise 函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line">功能: 给调用的进程本身发送信号.</span><br><span class="line">参数: sig 指定的信号</span><br><span class="line">返回值:</span><br><span class="line">	成功:  <span class="number">0</span></span><br><span class="line">	失败:  非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;aaaa\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">5</span>)&#123;</span><br><span class="line">               <span class="comment">//raise(SIGINT);</span></span><br><span class="line">               raise(SIGALRM);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a><strong>pause函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">功能：阻塞等待一个信号的产生/判断信号是否已经到达</span><br><span class="line">返回值：</span><br><span class="line">	当有信号产生时，函数返回‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;进程创建失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="comment">//父进程的代码区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程在运行中...\n&quot;</span>);</span><br><span class="line">        <span class="comment">//使用pause阻塞等待捕捉信号</span></span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//子进程的代码区 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程在运行中...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        kill(getppid(), SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line">功能: 当进程中产生某个信号时,对当前信号进行处理.</span><br><span class="line">参数:</span><br><span class="line">sig :指定要处理的信号</span><br><span class="line">handler :处理方式</span><br><span class="line">	SIG_IGN: 当信号产生时,以缺省(忽略)的方式处理</span><br><span class="line">	SIG_DFL: 当信号产生时,以当前信号默认的方式处理.</span><br><span class="line">        </span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> :当信号产生时,通过信号处理函数自定义方式处理,函数名可以随便写.</span><br><span class="line">参数 表示当前的信号</span><br><span class="line">返回值: </span><br><span class="line">	成功: 返回函数的地址,该地址为此信号上一次注册的信号处理函数的地址.</span><br><span class="line">	失败: SIG_ERR</span><br></pre></td></tr></table></figure>

<p>小结：<code>signal()</code> 函数并不会阻塞调用它的代码，它的行为更类似于 Qt 中的 <code>connect()</code>，它只是在后台注册一个信号处理函数，并不影响代码的正常执行。</p>
<h3 id="signal函数的使用"><a href="#signal函数的使用" class="headerlink" title="signal函数的使用"></a>signal函数的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//以默认的方式处理信号</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span>(signal(SIGINT,SIG_DFL)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(signal(SIGQUIT,SIG_DFL)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(signal(SIGTSTP,SIG_DFL)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="comment">//以忽略的方式来处理信号</span></span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">     <span class="keyword">if</span>(signal(SIGINT,SIG_IGN)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(signal(SIGQUIT,SIG_IGN)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(signal(SIGTSTP,SIG_IGN)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="comment">//以用户自定义方式处理信号</span></span><br><span class="line">        <span class="keyword">if</span>(signal(SIGINT,handler)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(signal(SIGQUIT,handler)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(signal(SIGTSTP,handler)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  SIGKILL与SIGSTOP这两个信号是不能忽略的方式处理,只能以默认的方式处理.</span></span><br><span class="line"><span class="comment">     if(signal(SIGKILL,SIG_IGN)==SIG_ERR)&#123;</span></span><br><span class="line"><span class="comment">        perror(&quot;fail to signal&quot;);</span></span><br><span class="line"><span class="comment">        exit(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     if(signal(SIGSTOP,SIG_IGN)==SIG_ERR)&#123;</span></span><br><span class="line"><span class="comment">        perror(&quot;fail to signal&quot;);</span></span><br><span class="line"><span class="comment">        exit(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AAA\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sig==SIGINT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT正在处理!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(sig==SIGQUIT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT正在处理!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(sig==SIGTSTP)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGTSTP正在处理!!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="signal函数的使用-1"><a href="#signal函数的使用-1" class="headerlink" title="signal函数的使用"></a>signal函数的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *ret_handler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AAAAAAAAAA!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(signal(SIGINT,ret_handler)==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((ret_handler=signal(SIGINT,handler))==SIG_ERR)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>可重入函数是指函数可以由多个任务并发使用,而不必担心数据错误。可重入函数就可以被中断的函数,当前函数可在任何时刻中断它,并执行另一块代码,当执行完毕后,回到原来的代码还可以正常继续运行.</p>
<p>编写可重入函数:</p>
<ol>
<li><p>不使用静态的数据,全局变量(除非信号量互斥)</p>
</li>
<li><p>不调用动态内存分配,释放的函数</p>
</li>
<li><p>不调用任何不可重入的函数(标准的IO函数)</p>
</li>
</ol>
<p>常见的可重入函数列表:</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/14.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AAAAA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGINT,handler);</span><br><span class="line">    <span class="comment">//sleep是一个可重入函数,但是当执行信号处理函数之后,不会回到原来的位置继续睡眠.</span></span><br><span class="line">   <span class="comment">// sleep(6);</span></span><br><span class="line">    alarm(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么sleep函数也被称为可重入函数"><a href="#为什么sleep函数也被称为可重入函数" class="headerlink" title="为什么sleep函数也被称为可重入函数"></a>为什么sleep函数也被称为可重入函数</h3><p><code>sleep()</code> 函数被称为<strong>可重入函数</strong>的原因是，它符合可重入函数的定义。可重入函数可以在任意时刻被中断，并安全地被重新调用而不会引发数据错误。这意味着即使在执行过程中发生信号中断或函数被另一个线程调用，也不会产生副作用或数据不一致的问题。</p>
<p>以下是为什么 <code>sleep()</code> 被认为是可重入函数的具体原因：</p>
<ol>
<li><p><strong>不使用全局或静态数据</strong></p>
<ul>
<li><code>sleep()</code> 函数不会使用全局或静态数据。它仅涉及局部变量或者系统调用，因此每次调用 <code>sleep()</code> 都是独立的，不会因为并发调用产生冲突。</li>
</ul>
</li>
<li><p><strong>不会修改共享资源</strong></p>
<ul>
<li><code>sleep()</code> 不修改任何共享资源。它只是简单地使当前线程或进程进入睡眠状态，期间不涉及修改全局状态或者跨进程、跨线程的数据。</li>
</ul>
</li>
<li><p><strong>原子操作</strong></p>
<ul>
<li><code>sleep()</code> 通常只是一个系统调用，操作系统会挂起调用它的进程或线程，直到指定的时间过去为止。这种操作是原子的，不会产生部分执行的状态，即使在中断之后也不会影响再次调用的安全性。</li>
</ul>
</li>
<li><p><strong>可中断且安全</strong></p>
<ul>
<li>在某些操作系统中，<code>sleep()</code> 可以被信号中断，比如接收到 <code>SIGALRM</code> 等信号时，<code>sleep()</code> 会提前终止。然而，提前终止后系统仍然会安全地返回控制权，而不破坏程序状态或引发不一致的行为。</li>
</ul>
</li>
</ol>
<p><strong>可重入函数的定义</strong></p>
<p>可重入函数是一类特殊的函数，具有以下特征：</p>
<ul>
<li><strong>没有依赖全局或静态变量</strong>：函数内部使用的所有数据都通过局部变量或参数传递。</li>
<li><strong>不修改共享资源</strong>：函数不会修改全局状态或者共享的外部资源。</li>
<li><strong>可以被中断和再次调用</strong>：函数在执行时可以被信号中断并且可以在中断后重新调用，而不会影响程序的正确性。</li>
</ul>
<p>由于 <code>sleep()</code> 符合这些条件，它可以被认为是一个可重入函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AAAAA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    signal(SIGINT,handler);</span><br><span class="line">     <span class="comment">/*read也是可重入函数,在等待终端输入时,如果产生信号并执行信号处理函数,信号处理完之后,可以继续输入数据,*/</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">30</span>]=<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(read(<span class="number">0</span>,buffer,<span class="number">20</span>)==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer=[%s]\n&quot;</span>,buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>信号集是用来表示多个信号的数据类型.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">功能:初始化由<span class="built_in">set</span>指向的信号集,清除其中所有的信号即初始化一个空集信号集.</span><br><span class="line">参数: <span class="built_in">set</span> 集号集标识的地址,以后操作此信号集,对<span class="built_in">set</span>进行操作就可以了.</span><br><span class="line">返回值:</span><br><span class="line">	成功返回  <span class="number">0</span></span><br><span class="line">	失败返回 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line">功能: 初始化信号集<span class="built_in">set</span>,将信号集合设置为所有信号的集合.</span><br><span class="line">参数:   <span class="built_in">set</span> 集号集标识的地址,以后操作此信号集,对<span class="built_in">set</span>进行操作就可以了.</span><br><span class="line">返回值:</span><br><span class="line">	成功返回  <span class="number">0</span></span><br><span class="line">	失败返回 <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">功能: 将信号signum 加入到信号集合 <span class="built_in">set</span>之中.</span><br><span class="line">参数:</span><br><span class="line">	<span class="built_in">set</span> : 信号集标识的地址.</span><br><span class="line">	signum : 信号的编号</span><br><span class="line">返回值:</span><br><span class="line">	成功返回  <span class="number">0</span></span><br><span class="line">	失败返回 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">功能: 将信号signum 从信号集合 <span class="built_in">set</span>中删除.</span><br><span class="line">参数:</span><br><span class="line">	<span class="built_in">set</span> : 信号集标识的地址.</span><br><span class="line">	signum : 信号的编号</span><br><span class="line">返回值:</span><br><span class="line">	成功返回  <span class="number">0</span></span><br><span class="line">	失败返回 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line">功能: 查询signum标识的信号是否在信号集合<span class="built_in">set</span>之中.</span><br><span class="line">参数:</span><br><span class="line">	<span class="built_in">set</span> : 信号集标识的地址.</span><br><span class="line">	signum : 信号的编号</span><br><span class="line">返回值:</span><br><span class="line">	成功返回  在信号集中返回<span class="number">1</span>  不在信号集中返回<span class="number">0</span></span><br><span class="line">	失败返回  返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个信号集;</span></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化一个空的集号集;</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    ret=sigismember(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT不在信号集中%d\n&quot;</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加指定的信号集</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line">    ret=sigismember(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT信号在信号集中....%d\n&quot;</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="sigset-t等操作系统相关显示未定义"><a href="#sigset-t等操作系统相关显示未定义" class="headerlink" title="sigset_t等操作系统相关显示未定义"></a>sigset_t等操作系统相关显示未定义</h3><p>打开C++配置文件，将Cstandard中C17改为GNU17。</p>
<p>在 C 编程中，<code>C17</code> 和 <code>GNU17</code> 是两种不同的标准选项，具体差异如下：</p>
<ol>
<li><p><strong>C17 标准</strong></p>
<ul>
<li><code>C17</code> 是 ISO C 标准的一个版本，它是 C11 的一个小修订版（C17 的正式标准是 ISO&#x2F;IEC 9899:2018）。与 C11 相比，C17 主要修正了一些错误和不一致的地方，没有引入新功能。</li>
<li>当你在编译器中选择 <code>C17</code> 标准时，编译器会遵循 ISO&#x2F;IEC C 标准规范，不包含任何额外的扩展。这意味着只提供纯粹的标准 C 库功能，遵循最严格的标准兼容性。</li>
<li>因此，使用 <code>C17</code> 时，一些在 GNU 扩展中定义的类型和函数可能不可用，比如 <code>sigset_t</code>。</li>
</ul>
</li>
<li><p><strong>GNU17 标准</strong></p>
<ul>
<li><code>GNU17</code> 是 GCC（GNU 编译器）的一种扩展模式，基于 C17 标准，但同时引入了一些 GNU 扩展。GNU 扩展是一些超出 ISO C 标准规范的附加功能和库函数，用于提供额外的灵活性和实用性。</li>
<li>当你选择 <code>GNU17</code> 时，除了遵循 C17 标准之外，你还可以使用 GNU 特定的扩展功能，比如 POSIX 相关的类型和函数，包括 <code>sigset_t</code> 之类的类型。</li>
<li>这意味着在 <code>GNU17</code> 模式下，编译器会更宽松地允许使用一些在标准 C 中未定义的功能。</li>
</ul>
</li>
</ol>
<p>结论</p>
<ul>
<li><strong>C17</strong> 代表了纯粹的 ISO C 标准（不带任何扩展），因此某些非标准类型和函数可能无法使用。</li>
<li><strong>GNU17</strong> 则在遵循 C17 标准的基础上，增加了 GNU 特有的扩展功能，使得在编译过程中可以使用如 <code>sigset_t</code> 这样的 POSIX 类型。</li>
</ul>
<p>因此，当你使用 <code>C17</code> 标准时，由于该标准没有包含 POSIX 扩展，所以 <code>sigset_t</code> 类型未定义。而使用 <code>GNU17</code> 时，编译器启用了 GNU 扩展，所以 <code>sigset_t</code> 可以正常使用。</p>
<h2 id="信号阻塞集"><a href="#信号阻塞集" class="headerlink" title="信号阻塞集"></a>信号阻塞集</h2><p>​	每个进程都有一个阻塞集,它用来描述哪些信号递送到该进程的时候被阻塞(在信号发生时记住它,直到进程准备好时再将信号通知进程)。所谓的阻塞并<strong>不是禁止</strong>传送信号,而是<strong>暂缓</strong>信号的传送.若将被阻塞的信号从信号阻塞集中删除,且对应的信号在被阻塞时发生了,进程会收到相应的信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"> 功能:检查或修改信号阻塞集,根据how指定的方法对进程的阻塞集合进行修改,新的信号阻塞集由<span class="built_in">set</span>指定,而原先的信号阻塞集合由oldset保存.</span><br><span class="line"> 参数:</span><br><span class="line">    how : 信号阻塞集合的修改方法</span><br><span class="line">    SIG_BLOCK :向信号阻塞集中添加<span class="built_in">set</span> 信号集</span><br><span class="line">    SIG_UNBLOCK: 从信号阻塞集合中删除<span class="built_in">set</span> 集合</span><br><span class="line">    SIG_SETMASK : 将信号阻塞集合设为<span class="built_in">set</span> 集合</span><br><span class="line">    <span class="built_in">set</span> :  要操作的信号集地址</span><br><span class="line">    oldset : 保存原先信号集地址:</span><br><span class="line">    </span><br><span class="line">    注意: 若<span class="built_in">set</span> 为<span class="literal">NULL</span>,则不会改变信号阻塞集合,函数只把当前信号阻塞集合保存到oldset中.</span><br><span class="line">返回值:</span><br><span class="line">    成功:  返回<span class="number">0</span></span><br><span class="line">    失败:  返回<span class="number">-1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//将set信号集添加到信号阻塞集中</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 信号集在阻塞集中\n&quot;</span>);</span><br><span class="line">             sleep(<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将set集号集从信号阻塞集中删除</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 信号集在阻塞集中删除\n&quot;</span>);</span><br><span class="line">             sleep(<span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h1><h2 id="无名管道概述"><a href="#无名管道概述" class="headerlink" title="无名管道概述"></a><strong>无名管道概述</strong></h2><p>&#9;管道(pipe)又称无名管道.无名管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。 </p>
<p>&#9;任何一个进程在创建的时候，系统都会给他分配4G的虚拟内存，分为3G的用户空间和1G的内核空间，内核空间是所有进程公有的，<strong>无名管道就是创建在内核空间的</strong>，多个进程知道同一个无名管道的空间，就可以利用他来进行通信。</p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/13.png"></p>
<p>&#9;管道是最古老的UNIX IPC方式，其特点是:</p>
<ol>
<li><p>半双工，数据在同一时刻只能在一个方向上流动。 </p>
</li>
<li><p>数据只能从管道的一端写入，从另一端读出。 </p>
</li>
<li><p>写入管道中的数据遵循先入先出(FIFO)的规则。 </p>
</li>
<li><p>管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息等。 </p>
</li>
<li><p>管道不是普通的文件，不属于某个文件系统，其只存在于内存中。 </p>
</li>
<li><p>管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。 </p>
</li>
<li><p>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。 </p>
</li>
<li><p>管道没有名字，只能在具有公共祖先的进程之间使用。</p>
</li>
</ol>
<h2 id="无名管道的创建-–-pipe函数"><a href="#无名管道的创建-–-pipe函数" class="headerlink" title="无名管道的创建 – pipe函数"></a><strong>无名管道的创建 – pipe函数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line">功能：创建一个无名管道，返回两个文件描述符负责对管道进行读写操作</span><br><span class="line">参数：</span><br><span class="line">	pipefd：<span class="type">int</span>型数组的首地址，里面有两个元素</span><br><span class="line">	pipefd[<span class="number">0</span>] 负责对管道执行读操作</span><br><span class="line">	pipefd[<span class="number">1</span>] 负责对管道执行写操作</span><br><span class="line">返回值：</span><br><span class="line">	成功：<span class="number">0</span></span><br><span class="line">	失败：‐<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="pipe示例1："><a href="#pipe示例1：" class="headerlink" title="pipe示例1："></a>pipe示例1：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to create pipe.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipefd[0] == %d\n&quot;</span>, pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipefd[1] == %d\n&quot;</span>, pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为何pipefd[0]，pipefd[1]输出的是3与4，3与4表示什么？</strong></p>
<p>在上述代码中，<code>pipefd[0]</code> 和 <code>pipefd[1]</code> 分别输出了 <code>3</code> 和 <code>4</code>，这是因为它们是新创建的文件描述符（file descriptors），在 Linux 和 Unix 系统中，文件描述符是用于表示打开文件或 I&#x2F;O 资源的整数。</p>
<ol>
<li><p><strong>文件描述符的基本概念</strong></p>
<ul>
<li>在 Unix&#x2F;Linux 系统中，每个进程都有一个文件描述符表，用于管理该进程打开的文件或其他 I&#x2F;O 资源。</li>
<li>文件描述符是一个非负整数，通常从 0 开始。</li>
<li>常见的标准文件描述符：<ul>
<li><code>0</code>: 标准输入（stdin）</li>
<li><code>1</code>: 标准输出（stdout）</li>
<li><code>2</code>: 标准错误输出（stderr）</li>
</ul>
</li>
</ul>
<p>这些是默认分配的文件描述符，当你打开新的文件或创建新的 I&#x2F;O 通道（如管道）时，系统会分配未使用的最小整数作为新的文件描述符。</p>
</li>
<li><p><strong><code>pipe()</code> 函数的行为</strong></p>
<ul>
<li><code>pipe()</code> 函数用于创建一个匿名管道，它会生成两个文件描述符，一个用于读取数据（<code>pipefd[0]</code>），另一个用于写入数据（<code>pipefd[1]</code>）。</li>
<li>当你调用 <code>pipe(pipefd)</code> 时，系统会分配两个新的文件描述符来表示管道的读端和写端。</li>
<li>由于文件描述符 <code>0</code>, <code>1</code>, <code>2</code> 已经分别用于标准输入、标准输出和标准错误输出，所以系统会从 <code>3</code> 开始为新创建的资源分配文件描述符。</li>
</ul>
</li>
<li><p><strong>为什么是 <code>3</code> 和 <code>4</code></strong></p>
<ul>
<li>在你的程序中，管道创建后，系统为其分配了文件描述符 <code>3</code> 和 <code>4</code>，分别表示管道的读端和写端。这是因为文件描述符 <code>0</code>, <code>1</code>, <code>2</code> 已经被占用了，所以系统从 <code>3</code> 开始分配给新的 I&#x2F;O 资源。</li>
<li>具体来说：<ul>
<li><code>pipefd[0] = 3</code>: 这是管道的读端，用于从管道中读取数据。</li>
<li><code>pipefd[1] = 4</code>: 这是管道的写端，用于向管道中写入数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="pipe示例2"><a href="#pipe示例2" class="headerlink" title="pipe示例2:"></a>pipe示例2:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用pipe创建一个无名管道</span></span><br><span class="line">    <span class="type">int</span> fd_pipe[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(fd_pipe) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd_pipe[0] = %d\n&quot;</span>, fd_pipe[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd_pipe[1] = %d\n&quot;</span>, fd_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对无名管道执行读写操作</span></span><br><span class="line">    <span class="comment">//由于无名管道给当前用户进程两个文件描述符，所以只要操作这两个文件</span></span><br><span class="line">    <span class="comment">//描述符就可以操作无名管道，所以通过文件IO中的read和write函数对无名管道进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过write函数向无名管道中写入数据</span></span><br><span class="line">    <span class="comment">//fd_pipe[1]负责执行写操作</span></span><br><span class="line">    <span class="comment">//如果管道中有数据，再次写入的数据会放在之前数据的后面，不会把之前的数据替换</span></span><br><span class="line">    <span class="keyword">if</span>(write(fd_pipe[<span class="number">1</span>], <span class="string">&quot;I am a teacher&quot;</span>, <span class="number">14</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to write&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(fd_pipe[<span class="number">1</span>], <span class="string">&quot;this is a book&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;this is a book&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过read函数从无名管道中读取数据</span></span><br><span class="line">    <span class="comment">//fd_pipe[0]负责执行读操作</span></span><br><span class="line">    <span class="comment">//读取数据时，直接从管道中读取指定个数的数据，如果管道中没有数据了，则read函数会阻塞等待</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes;</span><br><span class="line">    <span class="keyword">if</span>((bytes = read(fd_pipe[<span class="number">0</span>], buf, <span class="number">20</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = [%s]\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bytes = %ld\n&quot;</span>, bytes);</span><br><span class="line"> </span><br><span class="line">    bytes = read(fd_pipe[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = [%s]\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bytes = %ld\n&quot;</span>, bytes);</span><br><span class="line">   </span><br><span class="line">    bytes = read(fd_pipe[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = [%s]\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bytes = %ld\n&quot;</span>, bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="无名管道实现进程间通信"><a href="#无名管道实现进程间通信" class="headerlink" title="无名管道实现进程间通信"></a><strong>无名管道实现进程间通信</strong></h2><p><strong>注意：</strong> </p>
<p>&#9;利用无名管道实现进程间的通信，都是父进程创建无名管道，然后再创建子进程，子进程继承父进程的无名管道的文件描述符，然后父子进程通过读写无名管道实现通信.</p>
<h3 id="匿名管道进程通信规范示例"><a href="#匿名管道进程通信规范示例" class="headerlink" title="匿名管道进程通信规范示例"></a>匿名管道进程通信规范示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编写一个程序，实现父子进程间通过无名管道传递一个整数数组。父进程生成一个随机整数数组，并将该数组通过管道发送给子进程，子进程接收并计算数组元素的和。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//原始：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to create pipe.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程: \n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> getNumArray[Length];</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            read(pipefd[<span class="number">0</span>], getNumArray+i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            sum += getNumArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum = %d&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程: \n&quot;</span>);</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="comment">// 生成一个随机数</span></span><br><span class="line">        <span class="type">int</span> randomNumber;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            randomNumber = rand();</span><br><span class="line">            write(pipefd[<span class="number">1</span>], &amp;randomNumber, <span class="keyword">sizeof</span>(randomNumber));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//规范版：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Length = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to create pipe.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to fork.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程：读取数据并计算和</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 子进程关闭写端</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> getNumArray[Length];</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取整个数组</span></span><br><span class="line">        read(pipefd[<span class="number">0</span>], getNumArray, <span class="keyword">sizeof</span>(getNumArray));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += getNumArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程: 数组元素的和 = %d\n&quot;</span>, sum);</span><br><span class="line">        </span><br><span class="line">        close(pipefd[<span class="number">0</span>]);  <span class="comment">// 关闭读端</span></span><br><span class="line">        _exit(<span class="number">0</span>);  <span class="comment">// 子进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程：生成随机数数组并发送</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);  <span class="comment">// 父进程关闭读端</span></span><br><span class="line">        <span class="type">int</span> randomNumberArray[Length];</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程: 生成的随机数组为: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            randomNumberArray[i] = rand() % <span class="number">100</span>;  <span class="comment">// 生成100以内的随机数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, randomNumberArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将整个数组写入管道</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], randomNumberArray, <span class="keyword">sizeof</span>(randomNumberArray));</span><br><span class="line"></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);  <span class="comment">// 关闭写端</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);<span class="comment">// 等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进要点总结：</strong></p>
<ol>
<li><strong>关闭不必要的文件描述符</strong>：确保父进程和子进程只关闭不需要的管道端。</li>
<li><strong>父进程等待子进程结束</strong>：使用 <code>wait()</code> 或 <code>waitpid()</code> 防止子进程变成僵尸进程。</li>
<li><strong>使用块读写操作</strong>：避免每次只读写一个字节或一个整数，可以使用整个数组的大小进行一次性读写。</li>
<li><strong>防止僵尸进程</strong>：确保子进程使用 <code>_exit(0)</code> 正常退出。</li>
</ol>
<p>这样做可以避免很多潜在的错误并提高程序的健壮性。</p>
<h2 id="无名管道的读写规律"><a href="#无名管道的读写规律" class="headerlink" title="无名管道的读写规律"></a><strong>无名管道的读写规律</strong></h2><h3 id="读写端都存在，只读不写"><a href="#读写端都存在，只读不写" class="headerlink" title="读写端都存在，只读不写"></a><strong>读写端都存在，只读不写</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(pipefd[<span class="number">1</span>], <span class="string">&quot;hello world&quot;</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong> ：读写端都存在，只读不写 如果管道中有数据，会正常读取数据；如果管道中没有数据，则读操作会阻塞等待，直到有数据为止</p>
<h3 id="读写端都存在，只写不读"><a href="#读写端都存在，只写不读" class="headerlink" title="读写端都存在，只写不读"></a><strong>读写端都存在，只写不读</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读写端都存在，只写不读</span></span><br><span class="line">    <span class="comment">//如果一直执行写操作，则无名管道对应的缓冲区会被写满，写满之后，write函数也会阻塞等待</span></span><br><span class="line">    <span class="comment">//默认无名管道的缓冲区64K字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(write(pipefd[<span class="number">1</span>], <span class="string">&quot;6666&quot;</span>, <span class="number">1024</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：读写端都存在，只写不读，如果一直执行写操作，则无名管道对应的缓冲区会被写满，写满之后，write函数也会阻塞等待。默认无名管道的缓冲区64K字节</p>
<h3 id="只有读端，没有写端"><a href="#只有读端，没有写端" class="headerlink" title="只有读端，没有写端"></a><strong>只有读端，没有写端</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(pipefd[<span class="number">1</span>], <span class="string">&quot;hello world&quot;</span>,<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes;</span><br><span class="line">    <span class="keyword">if</span>((bytes = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bytes = %ld\n&quot;</span>, bytes);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除字符串中的内容</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((bytes = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to read&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bytes = %ld\n&quot;</span>, bytes);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>总结</strong>：关闭写文件描述符，只有读端。如果原本管道中有数据，则读操作正常读取数据，如果管道中没有数据，则read函数会返回0。</p>
<h3 id="只有写端，没有读端"><a href="#只有写端，没有读端" class="headerlink" title="只有写端，没有读端"></a><strong>只有写端，没有读端</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE信号产生了，管道破裂了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGPIPE, handler);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(write(pipefd[<span class="number">1</span>], <span class="string">&quot;hello world&quot;</span>, <span class="number">1024</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>总结</strong>:  关闭读操作文件描述符，只有写端，如果关闭读端，一旦执行写操作，就会产生一个信号<strong>SIGPIPE（管道破裂）</strong>，这个信号的默认处理方式是退出进程。</p>
<h2 id="通过fcntl函数设置文件的阻塞特性"><a href="#通过fcntl函数设置文件的阻塞特性" class="headerlink" title="通过fcntl函数设置文件的阻塞特性"></a><strong>通过fcntl函数设置文件的阻塞特性</strong></h2><p><strong>设置为阻塞：</strong> </p>
<p><code>fcntl(fd, F_SETFL, 0); </code></p>
<p><strong>设置为非阻塞：</strong> </p>
<p><code>fcntl(fd, F_SETFL, O_NONBLOCK); </code></p>
<p>&#9;如果是阻塞，管道中没有数据，read会一直等待，直到有数据才会继续运行，否则一直等待。 </p>
<p>&#9;如果是非阻塞，<code>read</code>函数运行时，会先看一下管道中是否有数据，如果有数据，则正常运行读取数据，如果管道中没有数据，则read函数会立即返回，继续下面的代码运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd_pipe[<span class="number">2</span>];</span><br><span class="line">	<span class="type">char</span> buf[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd_pipe) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fail to pipe&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fail to fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">			write(fd_pipe[<span class="number">1</span>], buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将fd_pipe[0]设置为阻塞</span></span><br><span class="line">		<span class="comment">//fcntl(fd_pipe[0], F_SETFL, 0);</span></span><br><span class="line">		<span class="comment">//将fd_pipe[0]设置为非阻塞</span></span><br><span class="line">		<span class="comment">//fcntl(fd_pipe[0], F_SETFL, O_NONBLOCK);</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">			read(fd_pipe[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;buf=[%s]\n&quot;</span>, buf);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件描述符概述"><a href="#文件描述符概述" class="headerlink" title="文件描述符概述"></a><strong>文件描述符概述</strong></h2><p>&#9;文件描述符（<code>File Descriptor</code>, 简称<code> FD</code>）是操作系统中用来表示打开的文件、管道、网络连接等的抽象标识符。它是一个非负整数，由内核维护，用于管理对文件和其他资源的访问。在 <code>Unix </code>和<code>Linux</code>系统中，文件描述符是系统调用接口中的核心概念，几乎所有的 I&#x2F;O 操作（如读、写、打开、关闭文件）都基于文件描述符进行。</p>
<h3 id="文件描述符的基本概念："><a href="#文件描述符的基本概念：" class="headerlink" title="文件描述符的基本概念："></a><strong>文件描述符的基本概念：</strong></h3><ol>
<li><p><strong>整数标识符</strong>: 文件描述符是一个简单的非负整数（如 0, 1, 2 等），它在进程打开一个文件或其他 I&#x2F;O 资源时由内核分配。每个进程有自己独立的文件描述符表，用来记录该进程打开的文件。</p>
</li>
<li><p><strong>标准文件描述符</strong>: 每个进程在创建时，都会默认打开三个标准文件描述符：</p>
<ul>
<li><strong>标准输入（stdin）</strong>: 文件描述符 0，通常指向键盘输入。</li>
<li><strong>标准输出（stdout）</strong>: 文件描述符 1，通常指向终端输出。</li>
<li><strong>标准错误（stderr）</strong>: 文件描述符 2，通常指向终端的错误输出。</li>
</ul>
</li>
<li><p><strong>抽象层</strong>: 文件描述符作为一个抽象层，隐藏了底层 I&#x2F;O 的实现细节。无论是操作文件、管道、设备、还是网络套接字，系统都会为其分配文件描述符，使得这些资源的访问方式保持一致。</p>
</li>
</ol>
<p><strong>文件描述符的生命周期</strong></p>
<ol>
<li><strong>分配</strong>: 当进程使用 <code>open()</code> 或 <code>socket()</code> 等系统调用打开文件或网络连接时，内核为该资源分配一个文件描述符。</li>
<li><strong>使用</strong>: 进程可以通过 <code>read()</code>、<code>write()</code> 等系统调用对文件描述符执行 I&#x2F;O 操作。</li>
<li><strong>关闭</strong>: 当不再需要使用文件描述符时，进程调用 <code>close()</code> 释放它。关闭文件描述符是必须的操作，否则会导致资源泄漏。</li>
</ol>
<p><strong>文件描述符表</strong></p>
<p>每个进程维护一个文件描述符表，它是一个数组，其中每个元素都包含一个指向内核文件表项的指针。文件表项包含文件的实际状态信息，如文件偏移量、访问模式（读、写）、引用计数等。</p>
<ul>
<li><p><strong>文件描述符表</strong>: 记录每个打开文件的描述符，进程通过文件描述符表来访问文件。</p>
</li>
<li><p><strong>文件表项</strong>: 文件表项是一个内核数据结构，保存了有关打开文件的详细信息。所有进程共享文件表项，它们通过文件描述符访问文件表项的内容。其包含了：</p>
<ul>
<li><strong>文件位置指针（File Offset）</strong>: 当前文件读写位置的偏移量，用于文件的读写操作。每个进程的文件描述符表中的文件描述符可能会有不同的偏移量。</li>
<li><strong>文件状态标志（File Status Flags）</strong>: 文件的状态信息，例如只读、读写模式等。</li>
<li><strong>文件控制块（File Control Block）</strong>: 包括指向文件系统中的 inode 的指针或索引，表示文件的实际位置和属性。</li>
<li><strong>引用计数（Reference Count）</strong>: 表示有多少文件描述符或进程正在使用这个文件表项。当引用计数为零时，文件表项会被释放。</li>
</ul>
<blockquote>
<p>注意：多个文件描述符可以指向同一个文件表项。例如，<code>dup()</code> 系统调用创建的文件描述符就是指向同一个文件的副本，它们共享文件表项。</p>
</blockquote>
</li>
</ul>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/31.png"></p>
<p><strong>常见场景</strong></p>
<ol>
<li><p><strong>重定向</strong>: 文件描述符可以用于重定向标准输入、输出。例如，将标准输出重定向到文件或其他设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">dup2(fd, <span class="number">1</span>);  <span class="comment">// 将文件描述符 1（stdout）重定向到文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>管道（Pipe）</strong>: 管道是一种特殊的文件描述符，允许进程间通信。创建管道时会产生两个文件描述符，一个用于读取（<code>pipefd[0]</code>），一个用于写入（<code>pipefd[1]</code>）。</p>
</li>
<li><p><strong>网络编程</strong>: 套接字（Socket）是网络连接的抽象，也通过文件描述符进行操作。网络连接的建立、数据的收发等都依赖文件描述符。</p>
</li>
</ol>
<p><strong>小结</strong></p>
<ul>
<li><strong>文件描述符</strong> 是一个整数，用于标识打开的文件或其他 I&#x2F;O 资源。</li>
<li>通过文件描述符，进程可以进行读、写、关闭等操作。</li>
<li>文件描述符在操作系统中提供了一个统一的接口，用于管理文件、设备、管道、网络连接等各种资源。</li>
<li>每个进程都有独立的文件描述符表，且系统在打开文件时分配的文件描述符是进程范围内唯一的。</li>
</ul>
<p><strong>注意：</strong> </p>
<p><code>Linux</code>中一个进程最多只能打开<code>NR_OPEN_DEFAULT</code>（即1024）个文件，故当文件不再使用时应及时调用close函数关闭文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">int</span> fd;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY | O_CREAT, <span class="number">0664</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to open&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd=%d\n&quot;</span>,fd);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>open</code>、<code>read</code> 和 <code>write</code> 是 C 语言中用于文件操作的系统调用。它们常用于直接操作文件描述符进行低级别文件操作。</p>
<h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a><code>open</code> 函数</h3><p><code>open</code> 函数用于打开文件，并返回一个文件描述符（file descriptor），后续对文件的操作通过该文件描述符进行。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>pathname</strong>: 文件路径（字符串）。</li>
<li><strong>flags</strong>: 文件的打开方式和标志，如 <code>O_RDONLY</code>（只读）、<code>O_WRONLY</code>（只写）、<code>O_RDWR</code>（读写）、<code>O_CREAT</code>（文件不存在时创建它）、<code>O_TRUNC</code>（截断文件为0字节）。</li>
<li><strong>mode</strong>（可选）: 当使用 <code>O_CREAT</code> 标志创建新文件时，必须指定文件权限，如 <code>0644</code> 表示用户有读写权限，组和其他用户只有读权限。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回文件描述符，是一个非负整数。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code> 来指示错误原因。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a><code>read</code> 函数</h3><p><code>read</code> 函数用于从文件或其他文件描述符中读取数据，将读取的数据存储到指定的缓冲区中。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>fd</strong>: 文件描述符。</li>
<li><strong>buf</strong>: 读取数据存放的缓冲区（指针）。</li>
<li><strong>count</strong>: 读取的字节数。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回读取的字节数（可以小于 <code>count</code>，表示已经读取到文件末尾）。</li>
<li>返回 <code>0</code> 表示到达文件末尾。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"><span class="type">ssize_t</span> bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to read file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a><code>write</code> 函数</h3><p><code>write</code> 函数用于将数据写入文件或其他文件描述符。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>fd</strong>: 文件描述符。</li>
<li><strong>buf</strong>: 写入的数据（指针）。</li>
<li><strong>count</strong>: 要写入的字节数。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回实际写入的字节数。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">ssize_t</span> bytes_written = write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"><span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Failed to write to file&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>综合使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to write to file&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a><code>close</code>函数</h3><p><code>close</code> 函数用于关闭文件描述符，当不再需要访问文件时，应该调用此函数来释放文件描述符资源。文件描述符是系统级别的资源，通常一个进程最多可以打开一定数量的文件描述符，所以合理关闭不再使用的文件描述符非常重要。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>fd</strong>: 文件描述符，需要关闭的文件或设备的标识符，由 <code>open</code> 或其他系统调用返回。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回 <code>0</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code> 来指示错误原因。常见错误包括：<ul>
<li><code>EBADF</code>: 无效的文件描述符（可能已经关闭或从未打开）。</li>
<li><code>EINTR</code>: <code>close</code> 被信号中断，调用可能需要重试。</li>
</ul>
</li>
</ul>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>释放资源</strong>: 关闭文件描述符后，内核会释放与文件描述符关联的资源，如缓冲区、文件表项等。</li>
<li><strong>写入缓冲区内容</strong>: 对于以 <code>O_WRONLY</code> 或 <code>O_RDWR</code> 方式打开的文件，<code>close</code> 会确保将缓冲区中剩余的数据刷新到磁盘（类似 <code>fflush</code> 的功能）。</li>
<li><strong>同步到文件系统</strong>: 当关闭一个打开的文件时，文件系统会确保所有的写操作都同步到磁盘上，从而保证数据的一致性。</li>
<li><strong>更新引用计数</strong>: 在 Unix 系统中，多个文件描述符可能指向同一个文件表项（如通过 <code>dup</code> 或 <code>fork</code> 创建的文件描述符）。在这种情况下，<code>close</code> 函数减少文件表项的引用计数，当引用计数降为零时，才真正释放文件相关的资源。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><strong>重复关闭</strong>:  对同一个文件描述符多次调用 <code>close</code> 会导致错误，第二次及之后的调用会返回 <code>-1</code>，并设置 <code>errno</code> 为 <code>EBADF</code>（Bad File Descriptor）。。</li>
<li><strong>关闭标准输入&#x2F;输出&#x2F;错误</strong>: 如果不小心关闭了标准输入 (<code>stdin</code>)、标准输出 (<code>stdout</code>) 或标准错误 (<code>stderr</code>)，可以使用 <code>dup2</code> 重新分配这些文件描述符，或通过 <code>freopen</code> 函数重新打开它们。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向文件写入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(fd, data, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to write to file&quot;</span>);</span><br><span class="line">        close(fd);  <span class="comment">// 关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to close file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File closed successfully.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细节解析</strong>：</p>
<ol>
<li><p>**<code>close(fd)</code>**：</p>
<ul>
<li>调用 <code>close</code> 时，内核会检查文件描述符 <code>fd</code> 是否有效。如果有效，则关闭文件，并释放与此文件描述符相关的资源。</li>
<li>成功时，<code>close</code> 返回 0；如果出现错误，返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
</li>
<li><p><strong>关闭缓冲区</strong>：</p>
<ul>
<li>对于输出操作，如果使用了缓冲区，<code>close</code> 会确保将缓冲区中的数据写入文件或设备。</li>
<li>因此，调用 <code>close</code> 不仅是释放资源，还包括确保数据完整性。</li>
</ul>
</li>
<li><p><strong>多次 <code>close</code> 的问题</strong>：</p>
<ul>
<li>如果一个文件描述符已经关闭，再次调用 <code>close</code> 会导致 <code>EBADF</code> 错误。更糟糕的是，如果文件描述符已经被另一个文件或资源重新使用，错误的 <code>close</code> 操作可能会关闭其他不相关的资源，导致难以调试的问题。</li>
</ul>
</li>
<li><p><strong>关闭管道和套接字</strong>：</p>
<ul>
<li>对于管道或套接字，<code>close</code> 的作用不仅仅是关闭文件描述符，还可能通知对端通信结束。例如，关闭写端可能会使得对端读端收到 <code>EOF</code>。</li>
</ul>
</li>
</ol>
<h2 id="文件描述符的复制"><a href="#文件描述符的复制" class="headerlink" title="文件描述符的复制"></a><strong>文件描述符的复制</strong></h2><p><code>dup</code> 和 <code>dup2</code> 是两个用于复制文件描述符的系统调用。它们可以将一个现有的文件描述符复制到一个新的文件描述符中，以实现多个文件描述符指向同一文件或设备。</p>
<h3 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup 函数"></a><code>dup</code> 函数</h3><p><code>dup</code> 函数用于创建一个新的文件描述符，该文件描述符是传入的文件描述符的副本。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>oldfd</strong>: 要复制的文件描述符。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回新的文件描述符。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code> 来指示错误原因。</li>
</ul>
<p><strong>行为</strong>：</p>
<ul>
<li>新的文件描述符是当前可用的最小整数。</li>
<li>新的文件描述符与 <code>oldfd</code> 共享相同的文件表项，因此它们共享同样的文件偏移量、文件状态标志（如 <code>O_RDONLY</code>, <code>O_WRONLY</code>），以及其他文件属性。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">int</span> fd2 = dup(fd1);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过dup函数复制一个文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">//dup执行后给返回值文件描述符分配的值是文件描述符表中最小可用的文件描述符</span></span><br><span class="line">    fd = dup(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd = %d\n&quot;</span>, fd);</span><br><span class="line">    <span class="comment">//由于通过dup函数将1这个文件描述符复制了一份为fd，所以fd现在就相当于1，所以写数据就是想终端写入数据</span></span><br><span class="line">    write(fd, <span class="string">&quot;this ia a book\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;this ia a book\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 输出重定向,先往文件输出,再回到标准输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd1;</span><br><span class="line">    <span class="type">int</span> fd2;</span><br><span class="line">    fd2=dup(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd2===%d\n&quot;</span>,fd2);</span><br><span class="line">    fd1=open(<span class="string">&quot;mm.txt&quot;</span>,O_RDWR |O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd1===%d\n&quot;</span>,fd1);</span><br><span class="line">    close(<span class="number">1</span>);  <span class="comment">//关闭标准输出文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd3=dup(fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AAAAAAAAAA\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd3===%d\n&quot;</span>,fd3);</span><br><span class="line">    </span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> fd4=dup(fd2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BBBBBBBB\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd4===%d\n&quot;</span>,fd4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dup2-函数"><a href="#dup2-函数" class="headerlink" title="dup2 函数"></a><code>dup2</code> 函数</h3><p><code>dup2</code> 函数也是用于复制文件描述符，但它允许将 <code>oldfd</code> 复制到一个指定的文件描述符 <code>newfd</code> 上。</p>
<p><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>oldfd</strong>: 要复制的文件描述符。</li>
<li><strong>newfd</strong>: 目标文件描述符。如果 <code>newfd</code> 已经被打开，那么它将被关闭，然后 <code>oldfd</code> 会复制到 <code>newfd</code> 上。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回 <code>newfd</code>。</li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<p><strong>行为</strong>：</p>
<ul>
<li>如果 <code>newfd</code> 等于 <code>oldfd</code>，则 <code>dup2</code> 什么也不做，直接返回 <code>newfd</code>。</li>
<li>如果 <code>newfd</code> 已经被打开，则在复制前会被自动关闭，避免文件描述符泄露。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">int</span> fd2 = dup2(fd1, <span class="number">10</span>);  <span class="comment">// 将 fd1 复制到文件描述符 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd1;</span><br><span class="line">	<span class="type">int</span> fd2;</span><br><span class="line">  </span><br><span class="line">	</span><br><span class="line">	fd1 = open(<span class="string">&quot;abc.txt&quot;</span>, O_CREAT | O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">	<span class="keyword">if</span> (fd1 &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">&quot;fail to open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先关闭1文件描述符，然后将fd1复制给1，意味着1和fd1都标识test.txt文件,返回值跟1是一样的</span></span><br><span class="line">	fd2 = dup2(fd1, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>, fd2);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd1;</span><br><span class="line">    <span class="comment">//如果使用dup2，则需要实现给第二个参数对应的变量赋一个初始值</span></span><br><span class="line">	<span class="type">int</span> fd2 = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将1复制一份为fd2，所以fd2标识的是标准输出</span></span><br><span class="line">	dup2(<span class="number">1</span>, fd2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>, fd2);</span><br><span class="line">	fd1 = open(<span class="string">&quot;test.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="comment">//输出重定向：关闭文件描述符1，将fd1复制一份为1，所以1此时标识的是test.txt文件</span></span><br><span class="line">	dup2(fd1, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="comment">//再次实现标准输出：关闭文件描述符1，将fd2复制一份为1，所以1此时标识的是标准输出</span></span><br><span class="line">	dup2(fd2, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;你好\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>相同点</strong></li>
</ol>
<ul>
<li><p><strong>文件描述符复制</strong>: 无论是 <code>dup</code> 还是 <code>dup2</code>，它们最终都会创建一个新的文件描述符，指向与 <code>oldfd</code> 相同的文件或设备。复制的文件描述符共享文件的偏移量、文件状态标志等。</p>
</li>
<li><p><strong>文件属性共享</strong>: 新的文件描述符与原始文件描述符共享同样的文件属性，如文件偏移量、访问模式（读、写）、锁等。这意味着通过其中一个文件描述符进行的操作会影响另一个文件描述符（例如，读写位置的改变）。</p>
</li>
</ul>
<ol start="4">
<li><strong>不同点</strong></li>
</ol>
<ul>
<li><p><strong>目标文件描述符的选择</strong>:</p>
<ul>
<li><code>dup</code>: 新的文件描述符是当前系统中可用的最小整数。</li>
<li><code>dup2</code>: 允许用户指定目标文件描述符 <code>newfd</code>，并且 <code>newfd</code> 可能是任意有效的文件描述符。如果 <code>newfd</code> 已经被占用，<code>dup2</code> 会关闭它并重新分配。</li>
</ul>
</li>
<li><p><strong>行为差异</strong>:</p>
<ul>
<li><code>dup</code> 只能分配新的文件描述符，而 <code>dup2</code> 则可以将文件描述符复制到一个指定的目标位置。如果目标位置已经打开，<code>dup2</code> 会在复制前关闭该文件描述符。</li>
</ul>
</li>
<li><p><strong>安全性</strong>:</p>
<ul>
<li><code>dup2</code> 可以避免文件描述符泄露的问题，因为它会在需要时关闭 <code>newfd</code>。而 <code>dup</code> 则只是简单地返回一个新的文件描述符。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><code>dup</code> 和 <code>dup2</code> 都是用于复制文件描述符的系统调用。</li>
<li><strong><code>dup</code></strong> 自动分配一个新的文件描述符，是系统中最小的可用整数。</li>
<li><strong><code>dup2</code></strong> 允许将文件描述符复制到一个指定的位置，如果该位置已经被占用，它会先关闭该文件描述符，然后再进行复制。</li>
</ul>
<p>通过这两个函数，可以实现进程内多个文件描述符指向同一个文件或设备的场景，比如重定向标准输入、输出等。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://gamma.fra1.zeabur.app">MegaV</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://gamma.fra1.zeabur.app/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://gamma.fra1.zeabur.app/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a href="null">null</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux-C/">Linux, C</a></div><div class="post-share"><div class="social-share" data-image="/img/user.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/11/04/hello-world/" title="Hello hexo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Hello hexo</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1234$ hexo serveror$ hexo s  More info: Server Generate static files123$ hexo generateor$ hexo g  More info: Generating Deploy to remote sites123$ hexo deployor$ hexo d  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">MegaV</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mokovi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m1447687747@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">零碎知识小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC"><span class="toc-number">1.1.</span> <span class="toc-text">GCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">GCC的编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">GCC的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">GCC的主要特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POSIX%E6%A0%87%E5%87%86"><span class="toc-number">1.2.</span> <span class="toc-text">POSIX标准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">进程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%9B%E5%88%B6%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">进程的调度进制：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%88Round-Robin-Scheduling%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">时间片轮转调度（Round Robin Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88Priority-Scheduling%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">优先级调度（Priority Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%EF%BC%88CFS%EF%BC%8CCompletely-Fair-Scheduling%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">完全公平调度（CFS，Completely Fair Scheduling）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CFS%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">CFS实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">进程控制块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">3.1.</span> <span class="toc-text">进程号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BAfork%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">进程的创建fork函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-number">3.3.</span> <span class="toc-text">程序区域划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">创建子进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bsleep-%E7%9D%A1%E7%9C%A0%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.</span> <span class="toc-text">进程sleep 睡眠状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85wait%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">进程的等待wait函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">waitpid函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2exit-exit"><span class="toc-number">3.8.</span> <span class="toc-text">进程的终止exit&#x2F;_exit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E6%B8%85%E7%90%86atexit"><span class="toc-number">3.9.</span> <span class="toc-text">进程退出清理atexit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E2%80%93vfork%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">进程的创建–vfork函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4-vfork%E5%88%9B%E5%BB%BA"><span class="toc-number">3.11.</span> <span class="toc-text">子进程和父进程共享同一块空间(&#x3D;vfork创建)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vfork-%E4%B8%8E-fork%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.12.</span> <span class="toc-text">vfork 与 fork的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9B%BF%E6%8D%A2exec"><span class="toc-number">3.13.</span> <span class="toc-text">进程的替换exec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system%E5%87%BD%E6%95%B0"><span class="toc-number">3.14.</span> <span class="toc-text">system函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system-%E4%B8%8E-exec-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">3.14.1.</span> <span class="toc-text">system 与 exec 的区别与相同点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">进程间通信概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">信号的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">信号的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">产生信号的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%BB%98%E8%AE%A4%EF%BC%88%E7%BC%BA%E7%9C%81%EF%BC%89%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">信号的默认（缺省）处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">进程接收到信号后的处理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">kill函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">alarm函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raise-%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">raise 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pause%E5%87%BD%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">pause函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#signal-%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">signal 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.7.1.</span> <span class="toc-text">signal函数的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8-1"><span class="toc-number">4.7.2.</span> <span class="toc-text">signal函数的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">可重入函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88sleep%E5%87%BD%E6%95%B0%E4%B9%9F%E8%A2%AB%E7%A7%B0%E4%B8%BA%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.1.</span> <span class="toc-text">为什么sleep函数也被称为可重入函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">4.9.</span> <span class="toc-text">信号集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sigset-t%E7%AD%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E6%98%BE%E7%A4%BA%E6%9C%AA%E5%AE%9A%E4%B9%89"><span class="toc-number">4.9.1.</span> <span class="toc-text">sigset_t等操作系统相关显示未定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%98%BB%E5%A1%9E%E9%9B%86"><span class="toc-number">4.10.</span> <span class="toc-text">信号阻塞集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">5.</span> <span class="toc-text">无名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">无名管道概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%88%9B%E5%BB%BA-%E2%80%93-pipe%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">无名管道的创建 – pipe函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E7%A4%BA%E4%BE%8B1%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">pipe示例1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E7%A4%BA%E4%BE%8B2"><span class="toc-number">5.2.2.</span> <span class="toc-text">pipe示例2:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">5.3.</span> <span class="toc-text">无名管道实现进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E8%A7%84%E8%8C%83%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">匿名管道进程通信规范示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A7%84%E5%BE%8B"><span class="toc-number">5.4.</span> <span class="toc-text">无名管道的读写规律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%AB%AF%E9%83%BD%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8F%AA%E8%AF%BB%E4%B8%8D%E5%86%99"><span class="toc-number">5.4.1.</span> <span class="toc-text">读写端都存在，只读不写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%AB%AF%E9%83%BD%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8F%AA%E5%86%99%E4%B8%8D%E8%AF%BB"><span class="toc-number">5.4.2.</span> <span class="toc-text">读写端都存在，只写不读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E8%AF%BB%E7%AB%AF%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%86%99%E7%AB%AF"><span class="toc-number">5.4.3.</span> <span class="toc-text">只有读端，没有写端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E5%86%99%E7%AB%AF%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%AF%BB%E7%AB%AF"><span class="toc-number">5.4.4.</span> <span class="toc-text">只有写端，没有读端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87fcntl%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E7%89%B9%E6%80%A7"><span class="toc-number">5.5.</span> <span class="toc-text">通过fcntl函数设置文件的阻塞特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">5.6.</span> <span class="toc-text">文件描述符概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">5.6.1.</span> <span class="toc-text">文件描述符的基本概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open-%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.2.</span> <span class="toc-text">open 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.3.</span> <span class="toc-text">read 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.4.</span> <span class="toc-text">write 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.5.</span> <span class="toc-text">close函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">5.7.</span> <span class="toc-text">文件描述符的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dup-%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.1.</span> <span class="toc-text">dup 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dup2-%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.2.</span> <span class="toc-text">dup2 函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux C学习笔记">Linux C学习笔记</a><time datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/04/hello-world/" title="Hello hexo">Hello hexo</a><time datetime="2024-11-04T12:51:49.686Z" title="Created 2024-11-04 20:51:49">2024-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By MegaV</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>