<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux C学习笔记 | MegaV的博客</title><meta name="author" content="MegaV"><meta name="copyright" content="MegaV"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux C学习笔记">
<meta property="og:url" content="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="MegaV的博客">
<meta property="og:description" content="零碎知识小结GCCGCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。 GCC的编译过程程序的编译过程可以分为四个主要阶段：  预编译：该阶段进行宏替换">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/user.jpg">
<meta property="article:published_time" content="2024-11-05T11:33:22.000Z">
<meta property="article:modified_time" content="2024-11-06T11:24:51.478Z">
<meta property="article:author" content="MegaV">
<meta property="article:tag" content="Linux, C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/user.jpg"><link rel="shortcut icon" href="/img/blog.png"><link rel="canonical" href="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux C学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-06 19:24:51',
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MegaV的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Linux C学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Linux C学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-06T11:24:51.478Z" title="Updated 2024-11-06 19:24:51">2024-11-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="零碎知识小结"><a href="#零碎知识小结" class="headerlink" title="零碎知识小结"></a>零碎知识小结</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC（GNU Compiler Collection，GNU编译器集合）是一个广泛使用的开源编译器套件，支持多种编程语言，最初仅支持C语言，后来逐渐扩展支持C++、Fortran、Ada、Go、Objective-C、D等语言。作为GNU计划的一部分，GCC旨在为各种平台提供自由和开源的编译工具。</p>
<h3 id="GCC的编译过程"><a href="#GCC的编译过程" class="headerlink" title="GCC的编译过程"></a>GCC的编译过程</h3><p>程序的编译过程可以分为四个主要阶段：</p>
<ol>
<li><p><strong>预编译</strong>：该阶段进行宏替换、删除注释、头文件包含以及条件编译等操作，生成一个预处理文件（<code>.i</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编译</strong>：将预处理后的<code>.i</code>文件编译成汇编文件（<code>.s</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>汇编</strong>：将汇编文件转换为二进制目标文件（<code>.o</code>），即机器代码。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>链接</strong>：将目标文件与库函数和启动代码链接，生成最终的可执行文件（通常是<code>a.out</code>，或在Windows下为<code>a.exe</code>）。</p>
<ul>
<li>命令示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的使用方式"><a href="#GCC的使用方式" class="headerlink" title="GCC的使用方式"></a>GCC的使用方式</h3><ol>
<li><p><strong>一步到位的编译</strong>：<br>默认情况下，GCC会将源代码直接编译成一个可执行文件<code>a.out</code>。</p>
<ul>
<li>编译并生成可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c</span><br></pre></td></tr></table></figure></li>
<li>运行程序：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out</span><br></pre></td></tr></table></figure></li>
<li>指定输出文件名：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o myhello</span><br><span class="line">./myhello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分步编译</strong>：<br>编译过程可以分为多个步骤进行，每个步骤都可以单独执行：</p>
<ul>
<li>预处理：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; hello.i</span><br></pre></td></tr></table></figure></li>
<li>编译：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i</span><br></pre></td></tr></table></figure></li>
<li>汇编：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s</span><br></pre></td></tr></table></figure></li>
<li>链接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>警告信息</strong>：<br>使用<code>-Wall</code>选项可以查看编译时的警告信息，有助于排除潜在的代码问题。</p>
<ul>
<li>编译并显示警告：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -Wall</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="GCC的主要特点"><a href="#GCC的主要特点" class="headerlink" title="GCC的主要特点"></a>GCC的主要特点</h3><ul>
<li><strong>多语言支持</strong>：GCC支持C、C++、Fortran、Ada、Go、Objective-C、D等多种编程语言。</li>
<li><strong>优化能力</strong>：GCC提供多种优化选项，如<code>-O2</code>、<code>-O3</code>等，帮助提升代码执行效率。</li>
<li><strong>跨平台支持</strong>：GCC支持多个操作系统和平台，如Linux、Windows、macOS、ARM等。</li>
<li><strong>标准化支持</strong>：GCC支持各种语言标准，特别是C和C++的最新标准。</li>
<li><strong>调试支持</strong>：GCC与调试器（如GDB）集成，提供调试功能。</li>
</ul>
<p>总结来说，GCC是一个强大的、开源的编译工具，适用于多种编程语言，并提供了丰富的优化和调试功能，广泛应用于各种开发场景。</p>
<h2 id="POSIX标准"><a href="#POSIX标准" class="headerlink" title="POSIX标准"></a>POSIX标准</h2><p>​	POSIX（<strong>Portable Operating System Interface for Unix</strong>）标准是由IEEE（Institute of Electrical and Electronics Engineers）制定的一系列标准，旨在定义操作系统接口（如系统调用、库函数等），以确保不同Unix系统之间的兼容性和可移植性。POSIX标准主要关注Unix和类Unix操作系统（如Linux、macOS、AIX等）之间的兼容性和一致性，使得应用程序能够在不同的操作系统平台之间移植而不需要进行大量的修改。</p>
<hr>
<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p><strong>1.程序和进程的区别：</strong> </p>
<p>​	<strong>程序：是静态的，存放在磁盘上的可执行文件</strong> </p>
<p>​	<strong>进程：是动态的，是运行在内存中的程序的执行实例</strong></p>
<p>​	程序是一些指令的有序集合，而进程是程序执行的过程，进程是程序的一次执行过程。 进程的状态是变化的，其包括进程的创建、调度和消亡。 当程序运行时，其就是进程，程序每运行一次，就会创建一个进程。在linux系统中，进程是管理事务的基本单元。 进程拥有自己独立的处理环境和系统资源（处理器、存储器、I&#x2F;O设备、数据、程序）。</p>
<p><strong>2.进程的状态及转换</strong></p>
<p>进程整个生命周期可以简单划分为<strong>三种状态</strong>： </p>
<p>​	<strong>就绪态：</strong> 进程已经具备执行的一切条件，正在等待分配CPU的处理时间。 </p>
<p>​	<strong>执行态：</strong> 该进程正在占用CPU运行。 </p>
<p>​	<strong>等待态：</strong> 进程因不具备某些执行条件而暂时无法继续执行的状态。</p>
<p><strong>进程三个状态的转换关系</strong></p>
<p><img src="/../source_img/Linux%20C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.assets/1.png"></p>
<p>引起进程状态转换的具体原因如下：</p>
<p>​	<strong>运行态→等待态</strong>：等待使用资源；如等待外设传输；等待人工干预。</p>
<p>​	<strong>等待态→就绪态</strong>：资源得到满足；如外设传输结束；人工干预完成。</p>
<p>​	<strong>运行态→就绪态</strong>：运行时间片到；出现有更高优先权进程。</p>
<p>​	<strong>就绪态—→运行态</strong>：CPU 空闲时选择一个就绪进程</p>
<h2 id="进程的调度进制："><a href="#进程的调度进制：" class="headerlink" title="进程的调度进制："></a><strong>进程的调度进制：</strong></h2><p>​	多进程不是说一个进程执行完再执行另一个进程，而是交替执行的，一个进程执行一段时间，然后下一个进程在执行一段时间，依次类推，所有进程执行完之后再回到第一个进程继续执行由此类推。在操作系统中，时间片轮转调度（Round Robin Scheduling）、优先级调度（Priority Scheduling）和完全公平调度（Completely Fair Scheduling，CFS）是三种常见的进程调度算法。</p>
<h3 id="时间片轮转调度（Round-Robin-Scheduling）"><a href="#时间片轮转调度（Round-Robin-Scheduling）" class="headerlink" title="时间片轮转调度（Round Robin Scheduling）"></a><strong>时间片轮转调度（Round Robin Scheduling）</strong></h3><p><strong>概述</strong>：<br>    时间片轮转调度是一种简单且常用的调度策略，特别适用于多任务环境中的时间共享系统。该策略的核心思想是为每个进程分配一个固定的时间片（Time Slice），当一个进程用完它的时间片后，操作系统会将其挂起，将CPU资源分配给下一个进程。所有的进程按顺序轮流执行，保证每个进程都能获得一定的CPU时间。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程按照固定的时间片执行，当时间片耗尽时，调度器会将进程切换出去，并将其状态保存，再选择下一个进程执行。</li>
<li>如果进程在其时间片内完成了任务，则该进程会被移除调度队列，继续执行下一个任务。</li>
<li>如果进程没有在时间片内完成，调度器会将其放回队列末尾，等待下次调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易实现，适用于多任务操作系统。</li>
<li>每个进程都可以得到公平的CPU时间。</li>
<li>特别适用于交互式任务，避免某些进程独占CPU时间。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>如果时间片设置得太小，频繁的上下文切换会增加开销。</li>
<li>不考虑进程的优先级，可能导致重要的进程在轮转时被延迟。</li>
<li>时间片的选择要合适，过大或过小都会影响系统性能。</li>
</ul>
<p><strong>应用场景</strong>：<br>适用于一般的桌面操作系统和基于时间共享的系统，如Linux和Windows中的用户进程调度。</p>
<h3 id="优先级调度（Priority-Scheduling）"><a href="#优先级调度（Priority-Scheduling）" class="headerlink" title="优先级调度（Priority Scheduling）"></a><strong>优先级调度（Priority Scheduling）</strong></h3><p><strong>概述</strong>：<br>优先级调度是一种基于优先级的调度算法。每个进程都被分配一个优先级值，调度器总是选择优先级最高的进程来执行。高优先级进程会优先于低优先级进程执行，直到它完成或者被阻塞为止。优先级可以是静态的（在进程创建时确定），也可以是动态的（在运行过程中根据进程的行为或外部因素调整）。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程有一个优先级，优先级可以由系统静态设定，或由用户和操作系统动态调整。</li>
<li>调度器选择队列中优先级最高的进程执行，如果多个进程优先级相同，则采用其他算法（如时间片轮转）来调度。</li>
<li>优先级调度可以是抢占式的，即当一个高优先级进程到达时，会抢占正在运行的低优先级进程；也可以是非抢占式的，即进程执行完一个时间片后才会进行调度。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可以确保高优先级的进程能及时得到执行，适合有不同重要性的任务。</li>
<li>对于实时任务或需要快速响应的进程非常有用。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>饥饿问题（Starvation）</strong>：低优先级的进程可能长时间得不到执行，特别是在高优先级进程一直占用CPU时。</li>
<li>不适用于所有任务，因为它忽视了进程的执行时间和公平性。</li>
<li>动态优先级调整可能增加系统的复杂性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于实时操作系统或任务需要严格响应时间的系统。</li>
<li>比如嵌入式系统中的任务调度和硬实时系统。</li>
</ul>
<h3 id="完全公平调度（CFS，Completely-Fair-Scheduling）"><a href="#完全公平调度（CFS，Completely-Fair-Scheduling）" class="headerlink" title="完全公平调度（CFS，Completely Fair Scheduling）"></a><strong>完全公平调度（CFS，Completely Fair Scheduling）</strong></h3><p><strong>概述</strong>：<br>完全公平调度（CFS）是Linux操作系统默认的调度算法，旨在为每个进程提供一个“公平”的CPU时间。与时间片轮转调度不同，CFS不使用固定的时间片，而是使用进程的“虚拟运行时间”（<code>virtual runtime</code>，简称<code>vruntime</code>）来决定哪个进程应该运行。CFS的目标是让每个进程尽可能公平地获得CPU时间，而不是通过固定的时间片来分配资源。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>每个进程都有一个<code>vruntime</code>值，表示该进程消耗的CPU时间。当一个进程运行时，它的<code>vruntime</code>会增加。</li>
<li>CFS通过一个红黑树（Red-Black Tree）来管理可执行的进程，树的根节点是<code>vruntime</code>最小的进程，这意味着它会被优先执行。</li>
<li>进程的<code>vruntime</code>会根据其实际运行时间动态调整，长时间运行的进程会让出CPU，短时间运行的进程会被优先调度。</li>
<li>CFS没有固定的时间片，而是基于进程的<code>vruntime</code>来决定调度顺序，进程越公平，<code>vruntime</code>的增加就越慢，调度时得到的CPU时间就越多。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>公平性</strong>：CFS最大程度地保证了进程之间的公平性，每个进程根据其CPU消耗时间来动态调整调度顺序。</li>
<li><strong>灵活性</strong>：相比时间片轮转调度，CFS具有更高的灵活性，可以动态调整每个进程的CPU时间分配，避免了不必要的频繁上下文切换。</li>
<li><strong>低延迟</strong>：对交互式进程提供较低的调度延迟，因为它总是优先调度<code>vruntime</code>较小的进程。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性较高，调度机制依赖于红黑树的实现，可能会增加系统的开销。</li>
<li>对于一些实时应用来说，CFS可能不能提供足够的响应保证，因为它更注重公平性而非严格的实时性。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>适用于需要平衡性能和公平性的多任务操作系统，如Linux。CFS是Linux的默认调度算法，适合各种通用计算任务。</li>
<li>不适用于实时性要求较高的任务。</li>
</ul>
<h4 id="CFS实例"><a href="#CFS实例" class="headerlink" title="CFS实例"></a>CFS实例</h4><p>​	为了更好地说明 <strong>完全公平调度（CFS）</strong> 的工作原理，我们可以通过一个更完善的例子来展示进程如何基于 <code>vruntime</code> 值进行调度，并解释不同优先级的进程如何影响 <code>vruntime</code> 的增长速率。</p>
<p>假设场景：</p>
<ul>
<li>系统中有三个进程：<code>进程 A</code>、<code>进程 B</code> 和 <code>进程 C</code>。</li>
<li>进程 A 是高优先级进程，<code>权重 = 1024</code>。</li>
<li>进程 B 是中等优先级进程，<code>权重 = 512</code>。</li>
<li>进程 C 是低优先级进程，<code>权重 = 256</code>。</li>
</ul>
<p>所有进程的初始 <code>vruntime</code> 为 0。</p>
<p>在此例中，我们假设每个进程的 <strong>执行时间</strong> 都为 5 毫秒。</p>
<p>步骤 1：进程 A 执行</p>
<ul>
<li><p>初始时，<code>进程 A</code> 的 <code>vruntime = 0</code>，<code>进程 B</code> 和 <code>进程 C</code> 的 <code>vruntime = 0</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 A</code> 执行，因为它的 <code>vruntime</code> 最小。</p>
</li>
<li><p>进程 A 执行了 5 毫秒。由于 <code>进程 A</code> 的权重为 1024，它的 <code>vruntime</code> 增加的速率较慢。假设 <code>vruntime</code> 增加的计算公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime 增加量 = 执行时间 × 权重因子 / 权重</span><br></pre></td></tr></table></figure>

<p>假设权重因子为 1，进程 A 的 <code>vruntime</code> 增加量是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_A = 5 × 1 / 1024 ≈ 0.00488</span><br></pre></td></tr></table></figure>

<p>进程 A 执行完后，<code>vruntime_A</code> 的新值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_A = 0 + 0.00488 = 0.00488</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 A</code> 执行完后的 <code>vruntime = 0.00488</code>。</p>
</li>
</ul>
<p>步骤 2：进程 C 执行</p>
<ul>
<li><p>当前时刻，<code>进程 A</code> 的 <code>vruntime = 0.00488</code>，<code>进程 B</code> 的 <code>vruntime = 0</code>，<code>进程 C</code> 的 <code>vruntime = 0</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 C</code> 执行，因为它的 <code>vruntime</code> 最小（与进程 B 相同，选择顺序可能不同，但我们假设先执行 C）。</p>
</li>
<li><p>进程 C 执行了 5 毫秒。由于 <code>进程 C</code> 的权重为 256，它的 <code>vruntime</code> 增加量会比进程 A 大。计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_C = 5 × 1 / 256 ≈ 0.01953</span><br></pre></td></tr></table></figure>

<p>进程 C 执行完后的 <code>vruntime</code> 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_C = 0 + 0.01953 = 0.01953</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 C</code> 执行完后的 <code>vruntime = 0.01953</code>。</p>
</li>
</ul>
<p>步骤 3：进程 B 执行</p>
<ul>
<li><p>当前时刻，<code>进程 A</code> 的 <code>vruntime = 0.00488</code>，<code>进程 B</code> 的 <code>vruntime = 0</code>，<code>进程 C</code> 的 <code>vruntime = 0.01953</code>。</p>
</li>
<li><p>CFS 会选择 <code>进程 B</code> 执行，因为它的 <code>vruntime</code> 最小。</p>
</li>
<li><p>进程 B 执行了 5 毫秒。由于 <code>进程 B</code> 的权重为 512，它的 <code>vruntime</code> 增加量比进程 A 小，但比进程 C 大。计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_B = 5 × 1 / 512 ≈ 0.00977</span><br></pre></td></tr></table></figure>

<p>进程 B 执行完后的 <code>vruntime</code> 为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime_B = 0 + 0.00977 = 0.00977</span><br></pre></td></tr></table></figure>

<p>所以，<code>进程 B</code> 执行完后的 <code>vruntime = 0.00977</code>。</p>
</li>
</ul>
<p>步骤 4：再次调度</p>
<p>此时，进程 A、B 和 C 的 <code>vruntime</code> 分别为：</p>
<ul>
<li><code>进程 A</code>：<code>vruntime = 0.00488</code></li>
<li><code>进程 B</code>：<code>vruntime = 0.00977</code></li>
<li><code>进程 C</code>：<code>vruntime = 0.01953</code></li>
</ul>
<p>接下来，CFS 会选择 <strong><code>vruntime</code> 最小的进程</strong> 来执行，这个进程是 <code>进程 A</code>，它的 <code>vruntime</code> 最小。然后调度会继续按照这种方式进行，直到所有进程完成执行。</p>
<p><strong>总结</strong>：</p>
<ol>
<li><p><strong>权重（优先级）决定了 <code>vruntime</code> 的增长速率</strong>：</p>
<ul>
<li>高优先级的进程（权重大）其 <code>vruntime</code> 增长较慢，因此可以更长时间占用 CPU。</li>
<li>低优先级的进程（权小）其 <code>vruntime</code> 增长较快，因此调度时优先级较低。</li>
</ul>
</li>
<li><p><strong>进程调度顺序是基于 <code>vruntime</code> 的</strong>，<code>vruntime</code> 越小的进程越容易被调度执行，CFS 会按照进程的 <code>vruntime</code> 值维护一个红黑树（基于红黑树来管理所有可执行的进程）。</p>
</li>
<li><p><strong>公平性</strong>：CFS 会确保所有进程在理论上能够获得相同的 CPU 时间，通过动态调整 <code>vruntime</code>，使得长期运行的进程逐渐让出 CPU 给其他进程。</p>
</li>
</ol>
<p>这种调度方式与传统的基于时间片的调度算法（如时间片轮转）不同，它根据每个进程的实际执行情况来调整调度策略，确保了调度的公平性。</p>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a><strong>进程控制块</strong></h2><p>​	<strong>进程控制块</strong>就是用于保存一个进程信息的结构体，又称之为<strong>PCB</strong>。OS是根据PCB来对并发执行的进程进行控制和管理的。系统在创建一个进程的时候会开辟 一段内存空间存放与此进程相关的PCB数据结构。 PCB是操作系统中最重要的记录型数据结构。PCB中记录了用于描述进程进展情况及控制进程运行所需的全部信息。 </p>
<p>​	PCB是进程存在的唯一标志，在Linux中PCB存放在task_struct结构体中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/src</span><br><span class="line">$ <span class="built_in">sudo</span> apt-get install ctags</span><br><span class="line"><span class="built_in">sudo</span> ctags -R</span><br><span class="line"></span><br><span class="line">查看结构体  vim -t task_struct</span><br></pre></td></tr></table></figure>

<p>​	调度数据 (进程的状态,标记优先级,调度策略等)</p>
<p>​	时间数据: 创建该进程的时间,在用户态的运行时间,在内核态的运行时间.</p>
<p>​	文件数据： 文件描述符表,内存数据,进程标识(进程号)</p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">MegaV</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux-C/">Linux, C</a></div><div class="post-share"><div class="social-share" data-image="/img/user.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/11/04/hello-world/" title="Hello hexo"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Hello hexo</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1234$ hexo serveror$ hexo s  More info: Server Generate static files123$ hexo generateor$ hexo g  More info: Generating Deploy to remote sites123$ hexo deployor$ hexo d  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">MegaV</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Mokovi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:m1447687747@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">零碎知识小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC"><span class="toc-number">1.1.</span> <span class="toc-text">GCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">GCC的编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">GCC的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCC%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">GCC的主要特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POSIX%E6%A0%87%E5%87%86"><span class="toc-number">1.2.</span> <span class="toc-text">POSIX标准</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">进程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E8%BF%9B%E5%88%B6%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">进程的调度进制：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%88Round-Robin-Scheduling%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">时间片轮转调度（Round Robin Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88Priority-Scheduling%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">优先级调度（Priority Scheduling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%EF%BC%88CFS%EF%BC%8CCompletely-Fair-Scheduling%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">完全公平调度（CFS，Completely Fair Scheduling）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CFS%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">CFS实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">进程控制块</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/05/Linux-C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux C学习笔记">Linux C学习笔记</a><time datetime="2024-11-05T11:33:22.000Z" title="Created 2024-11-05 19:33:22">2024-11-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/04/hello-world/" title="Hello hexo">Hello hexo</a><time datetime="2024-11-04T12:51:49.686Z" title="Created 2024-11-04 20:51:49">2024-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By MegaV</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>